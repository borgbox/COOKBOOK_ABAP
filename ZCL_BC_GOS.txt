* allgemeine Formroutinen
FORM auftragsmenge_ermitteln USING    ow_mcvbup-fksaa  TYPE fksaa
                                      ow_mcvbup-fksta  TYPE fksta
                                      ow_mcvbap-fkrel  TYPE fkrel
                                      ow_mcvbap-lsmeng TYPE lsmeng
                                      ow_mcvbap-kwmeng TYPE kwmeng
                                      ow_mcvbap-zmeng  TYPE dzmeng
                                      ow_mcvbapf-remng TYPE remenge
                                      ow_mcvbapf-wemng TYPE wemenge
                             CHANGING ow_mcvbap-olimeau TYPE mc_olimeau.
  IF     ow_mcvbap-fkrel CA con_fkrel_kwmeng.
    ow_mcvbap-olimeau = ow_mcvbap-kwmeng.
  ELSEIF ow_mcvbap-fkrel CA con_fkrel_lsmeng.
    ow_mcvbap-olimeau = ow_mcvbap-lsmeng.
  ELSEIF ow_mcvbap-fkrel CA con_fkrel_zmeng.
    ow_mcvbap-olimeau = ow_mcvbap-zmeng.
  ENDIF.
*   falls nicht eindeutig zuzuordnen und/oder Zielfeld initial
  IF ow_mcvbap-olimeau IS INITIAL.
    ow_mcvbap-olimeau = ow_mcvbap-kwmeng.
  ENDIF.
  IF ow_mcvbap-olimeau IS INITIAL.
    ow_mcvbap-olimeau = ow_mcvbap-lsmeng.
  ENDIF.
  IF ow_mcvbap-olimeau IS INITIAL.
    ow_mcvbap-olimeau = ow_mcvbap-zmeng.
  ENDIF.
  IF     ow_mcvbap-fkrel CA 'F' AND    "gemäß RE-Menge bei Strecke
         ow_mcvbapf-remng GT 0.
*  es wird solange mit der Auftragsmenge gearbeitet, bis die RE-Menge
*  größer 0 ist
    ow_mcvbap-olimeau = ow_mcvbapf-remng.
  ENDIF.

ENDFORM.                    "AUFTRAGSMENGE_ERMITTELN

*---------------------------------------------------------------------*
*       FORM AUFTRAGSMENGE_ERMITTELN_KM                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  OW_MCVBAP-LFREL                                               *
*  -->  OW_MCVBAP-FKREL                                               *
*  -->  OW_MCVBAP-LSMENG                                              *
*  -->  OW_MCVBAP-KWMENG                                              *
*  -->  OW_MCVBAP-KBMENG                                              *
*  -->  OW_MCVBAP-ZMENG                                               *
*  -->  OW_MCVBAP-OLIMEAU                                             *
*---------------------------------------------------------------------*
FORM auftragsmenge_ermitteln_km USING ow_mcvbap_lfrel  TYPE lfrel_ap
                                      ow_mcvbap_fkrel  TYPE fkrel
                                      ow_mcvbap_lsmeng TYPE lsmeng
                                      ow_mcvbap_kwmeng TYPE kwmeng
                                      ow_mcvbap_kbmeng TYPE kbmeng
                                      ow_mcvbap_zmeng  TYPE dzmeng
                             CHANGING ow_mcvbap_olimeau TYPE mc_olimeau.
* diese Routine wird genutzt um die offene Menge nach der Freigabe zu
* ermitteln (also KBMENG)
  IF     ow_mcvbap_fkrel CA con_fkrel_kwmeng.
    ow_mcvbap_olimeau = ow_mcvbap_kwmeng.
  ELSEIF ow_mcvbap_fkrel CA con_fkrel_lsmeng.
    IF ow_mcvbap_lfrel NE true.
*     dann sind doch die Einteilungen lieferrelvant
      ow_mcvbap_olimeau = ow_mcvbap_kbmeng.
    ELSE.
      ow_mcvbap_olimeau = ow_mcvbap_lsmeng.
    ENDIF.
  ELSEIF ow_mcvbap_fkrel CA con_fkrel_zmeng.
    ow_mcvbap_olimeau = ow_mcvbap_zmeng.
  ELSE.
    ow_mcvbap_olimeau = ow_mcvbap_lsmeng.
  ENDIF.
  IF ow_mcvbap_fkrel  CA 'F' AND       "gemäß RE-Menge bei Strecke
    ow_mcvbap_olimeau IS INITIAL.
    ow_mcvbap_olimeau = ow_mcvbap_kwmeng.
  ENDIF.
* Fakt.plan mit Zielmenge (z.B. Lastschr.anfo., Kontrakt)
  IF ow_mcvbap_olimeau IS INITIAL AND
     ow_mcvbap_fkrel EQ 'I'.
    ow_mcvbap_olimeau = ow_mcvbap_zmeng.
  ENDIF.
ENDFORM.                    "AUFTRAGSMENGE_ERMITTELN_KM

*---------------------------------------------------------------------*
*       FORM CHECK_APPLICATION_DATA                                   *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  XVBAP                                                         *
*  -->  YVBAP                                                         *
*  -->  XVBAK                                                         *
*  -->  YVBAK                                                         *
*  -->  MODUS                                                         *
*  -->  TRTYP                                                         *
*---------------------------------------------------------------------*
FORM check_application_data TABLES xvbap STRUCTURE vbapvb
                                   yvbap STRUCTURE vbapvb
                            USING  xvbak STRUCTURE vbak
                                   yvbak STRUCTURE vbak
                                   modus TYPE mcmodus
                                   trtyp TYPE trtyp.
  CHECK trtyp EQ 'V' AND
        modus NE con_modus_new.
  IF xvbak-vbeln NE yvbak-vbeln.
    MESSAGE a322 WITH 'VBAK'.
*   MESSAGE A322 WITH 'Program error in LMCS1U03 VBAK <-> SIS'.
  ENDIF.
*
  LOOP AT xvbap.
    CHECK xvbap-updkz EQ con_changed OR
          xvbap-updkz EQ con_deleted.
    LOOP AT yvbap WHERE mandt EQ xvbap-mandt
                  AND   vbeln EQ xvbap-vbeln
                  AND   posnr EQ xvbap-posnr.
    ENDLOOP.
    IF sy-subrc NE 0.
      MESSAGE a322 WITH 'VBAP'.
*     MESSAGE A322 WITH 'Program error in LMCS1U03 VBAP <-> SIS'.
    ENDIF.
  ENDLOOP.
ENDFORM.                    "CHECK_APPLICATION_DATA

*---------------------------------------------------------------------*
*       FORM FPLT_CALL                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  FC_SUHIE                                                      *
*---------------------------------------------------------------------*
FORM fplt_call USING fc_suhie TYPE c.
* Termine des Fakturierungsplans
  MOVE fc_suhie TO flg_suhie.
  flg_tmc2f_fplt = true.
  READ TABLE xmcfplt WITH KEY supkz = xmcvbak-supkz
                              mandt = xmcvbak-mandt
                              fplnr = xmcvbkd-fplnr BINARY SEARCH.
  IF sy-subrc EQ 0.
    LOOP AT xmcfplt FROM sy-tabix.
      Clear flag_bp_fakwr.
      IF xmcfplt-supkz NE xmcvbak-supkz
      OR xmcfplt-mandt NE xmcvbak-mandt
      OR xmcfplt-fplnr NE xmcvbkd-fplnr.
        EXIT.
      ENDIF.
      IF control-logging EQ true.
        MOVE xmcfplt-fkdat  TO mclogging-fkdat.
      ENDIF.
      PERFORM xmcfplt_werte USING xmcfplt xmcvbap xmcvbak-vbtyp.
      PERFORM update_call
        USING flg_suhie zeitp xmcvbap-stafo flg_tmc2f_fplt.
*     Termine des Fakturierungsplans zu den Konditionen
      CLEAR flg_tmc2f_komv.
*     Anreichern Konditionen bei periodischer Preisfindung
      PERFORM billing_plan_pricing_for_sis
        TABLES xmckomv
        USING  xmcfplt
               xmcvbak-knumv
               xmcvbap-posnr.
* in case a dateline in a periodic billing plan has a
* billing value = 0 subsequent date lines in the billing plan
* no longer contribute to the order intake in CO and CO-PA
* Flag have to be set in userexit billing_plan_pricing_for_sis
      IF flag_bp_fakwr = 'X'.
        continue.
      ENDIF.
      PERFORM komv_call USING con_suhie_komvfplt.
      MOVE fc_suhie TO flg_suhie.
      IF flg_tmc2f_fplt EQ false AND
         flg_tmc2f_komv EQ false.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  CLEAR: mclogging-fkdat.
ENDFORM.                    "FPLT_CALL

*---------------------------------------------------------------------*
*       FORM KOMV_CALL                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  KC_SUHIE                                                      *
*---------------------------------------------------------------------*
FORM komv_call USING kc_suhie TYPE c.
  MOVE kc_suhie TO flg_suhie.
  flg_tmc2f_komv = true.
  MOVE xmcvbap-supkz TO xmckomv_key-supkz.
  MOVE xmcvbak-mandt TO xmckomv_key-mandt.
  MOVE xmcvbak-knumv TO xmckomv_key-knumv.
  MOVE xmcvbap-posnr TO xmckomv_key-kposn.
  READ TABLE xmckomv WITH KEY supkz = xmckomv_key-supkz
                              mandt = xmckomv_key-mandt
                              knumv = xmckomv_key-knumv
                              kposn = xmckomv_key-kposn
                                          BINARY SEARCH.
  IF sy-subrc EQ 0.
    LOOP AT xmckomv FROM sy-tabix.
      IF xmckomv-supkz NE xmckomv_key-supkz
      OR xmckomv-mandt NE xmckomv_key-mandt
      OR xmckomv-knumv NE xmckomv_key-knumv
      OR xmckomv-kposn NE xmckomv_key-kposn.
        EXIT.
      ENDIF.
      IF control-logging EQ true.
        MOVE xmckomv-kschl  TO mclogging-kschl.
      ENDIF.
      PERFORM xmckomv_werte_auftrag USING xmckomv xmcvbap xmcvbak-vbtyp.
* Konditions- und Staffelbasis bei Intervallstaffeln ermitteln
      PERFORM kond_staffel_basis_korr USING xmckomv-knprs xmckomv-krech
                                         xmckomv-kzbzg xmckomv-kfaktor1
                               CHANGING  xmckomv-kawrt xmckomv-kstbs.
      PERFORM update_call
        USING flg_suhie zeitp xmcvbap-stafo flg_tmc2f_komv.
*     Termine des Fakturierungsplans zu den Konditionen
*     CLEAR FLG_TMC2F_FPLT.
*     IF FLG_SUHIE EQ CON_SUHIE_KOMV.
*       PERFORM FPLT_CALL USING CON_SUHIE_KOMVFPLT.
*       MOVE KC_SUHIE TO FLG_SUHIE.
*     ENDIF.
*     wenn keine Konditionsfortschreibung und keine FPLT-Fortschreibung
*     IF   FLG_TMC2F_KOMV EQ FALSE   AND
*          FLG_TMC2F_FPLT EQ FALSE.
      IF   flg_tmc2f_komv EQ false.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.
  CLEAR:
    mclogging-kschl.
ENDFORM.                    "KOMV_CALL

*---------------------------------------------------------------------*
*       FORM KOMV_READ                                                *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  KR_KOMV                                                       *
*  -->  KR_KNUMV                                                      *
*---------------------------------------------------------------------*
FORM komv_read TABLES kr_komv STRUCTURE komv
               USING kr_knumv TYPE knumv.

    DATA hkonv TYPE STANDARD TABLE OF konv.

    TRY.
       cl_prc_result_factory=>get_instance( )->get_prc_result( )->get_price_element_db_by_key(
          EXPORTING
             iv_knumv                      = kr_knumv
          IMPORTING
             et_prc_element_classic_format = hkonv ).

       kr_komv[] = hkonv[].

       CATCH cx_prc_result INTO DATA(lr_exc).
*        If something goes wrong here -> Abort!! Otherwise we risk corrupted data
*        This should never happens. If yes, then there is something wrong that needs coding corrections.
         MESSAGE X522(vh).
    ENDTRY.

ENHANCEMENT-POINT KOMV_READ_01 SPOTS ES_SAPLMCS1.
*$*$-Start: KOMV_READ_01------------------------------------------------------------------------$*$*
ENHANCEMENT 1  OIA_SAPLMCS1.    "active version
                                                         "SO7K017957 JP
* if fees exist for the document, select them as well
  read table kr_komv with key kntyp = '-'
                     transporting no fields.
  if sy-subrc eq 0.
*KH(del) select * from oianf appending table kr_komv
    select * from oianf appending
             corresponding fields of table kr_komv      "SO7K115812 KH
*   Reason for the change: Depending on the system history, KONV    KH
*   has different field order (SORTTABS) -> syntax error            KH
                        where knumv = kr_knumv.
    sort kr_komv by mandt knumv kposn stunr zaehk.
  endif.
ENDENHANCEMENT.
*$*$-End:   KOMV_READ_01------------------------------------------------------------------------$*$*
ENDFORM.                    "KOMV_READ

*---------------------------------------------------------------------*
*       FORM KOMV_READ_ALT                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  KRA_KOMV                                                      *
*  -->  KRA_XMCKOMV                                                   *
*  -->  KRA_KNUMV                                                     *
*  -->  KRA_SUPKZ                                                     *
*---------------------------------------------------------------------*
FORM komv_read_alt TABLES   kra_komv    STRUCTURE komv
                            kra_xmckomv STRUCTURE mckomvb
                   USING    kra_knumv   TYPE knumv
                   CHANGING kra_supkz   TYPE supkz.
  DATA: kra_tabix LIKE sy-tabix.
  READ TABLE kra_komv INDEX 1.
  IF sy-subrc EQ 0 AND
     kra_knumv = kra_komv-knumv.
    MOVE 1 TO kra_tabix.
  ENDIF.
  DESCRIBE TABLE kra_xmckomv LINES sy-tabix.
  READ TABLE kra_xmckomv INDEX sy-tabix.
* lesen letzer, da im Stornofall mehrere KNUMVs existieren, der
* aktuelle aber immer der letzte ist
  IF sy-subrc  EQ 0 AND
     kra_knumv =  kra_xmckomv-knumv.
    IF kra_xmckomv-supkz EQ con_supkz_unv.
      MOVE con_supkz_unv TO kra_supkz.
    ELSE.
      MOVE con_supkz_alt TO kra_supkz.
      IF kra_tabix EQ 0.
        PERFORM komv_read TABLES kra_komv USING kra_knumv.
      ENDIF.
    ENDIF.
  ELSE.
    MOVE con_supkz_alt TO kra_supkz.
    IF kra_tabix EQ 0.
      PERFORM komv_read TABLES kra_komv USING kra_knumv.
    ENDIF.
  ENDIF.
ENDFORM.                    "KOMV_READ_ALT

*---------------------------------------------------------------------*
*       FORM KOMV_READ_NEU                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  KRN_KOMV                                                      *
*  -->  KRN_KNUMV                                                     *
*  -->  KRN_SUPKZ                                                     *
*---------------------------------------------------------------------*
FORM komv_read_neu TABLES   krn_komv  STRUCTURE komv
                   USING    krn_knumv TYPE knumv
                   CHANGING krn_supkz TYPE supkz.
  DESCRIBE TABLE krn_komv LINES sy-tabix.
  IF sy-tabix EQ 0.
    MOVE con_supkz_unv TO krn_supkz.
    PERFORM komv_read TABLES krn_komv USING krn_knumv.
  ELSE.
    MOVE con_supkz_neu TO krn_supkz.
  ENDIF.
ENDFORM.                    "KOMV_READ_NEU

*---------------------------------------------------------------------*
*       FORM MC_TABLES_PREPARE                                        *
*---------------------------------------------------------------------*
*       1. Erzeugt alte Eintraege bei Aenderungstransaktionen, wenn   *
*          Tabellen nicht geaendert wurden                            *
*       2. Uebernimmt Partner in den Kopf und in die Position         *
*---------------------------------------------------------------------*
FORM mc_tables_prepare.
  READ TABLE xmcvbak INDEX 1.
  IF sy-subrc EQ 0 AND
     xmcvbak-abdis EQ space.
*   Zulieferer: Folgende FORM ist schon im Dialog gelaufen, da in
*               der Verbuchung die YVBLB nicht mehr vorhanden ist
    PERFORM mc_tables_prepare1 TABLES
        xmckomv
        xmcvbak
        xmcvbap
        xmcvbep
        xmcvbkd
        xmcvbpa
        xmcvbuk
        xmcvbup
        xmcvbapf
        xmcvbfa
        xmcfplt.
  ENDIF.
ENDFORM.                    "MC_TABLES_PREPARE

*---------------------------------------------------------------------*
*       FORM MC_TABLES_PREPARE1                                       *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  XMCKOMV                                                       *
*  -->  XMCVBAK                                                       *
*  -->  XMCVBAP                                                       *
*  -->  XMCVBEP                                                       *
*  -->  XMCVBKD                                                       *
*  -->  XMCVBPA                                                       *
*  -->  XMCVBUK                                                       *
*  -->  XMCVBUP                                                       *
*  -->  XMCVBAPF                                                      *
*  -->  XMCVBFA                                                       *
*  -->  XMCFPLT                                                       *
*---------------------------------------------------------------------*
FORM mc_tables_prepare1 TABLES
        xmckomv       STRUCTURE mckonvb
        xmcvbak       STRUCTURE mcvbakb
        xmcvbap       STRUCTURE mcvbapb
        xmcvbep       STRUCTURE mcvbepb
        xmcvbkd       STRUCTURE mcvbkdb
        xmcvbpa       STRUCTURE mcvbpab
        xmcvbuk       STRUCTURE mcvbukb
        xmcvbup       STRUCTURE mcvbupb
        xmcvbapf      STRUCTURE mcvbafb
        xmcvbfa       STRUCTURE mcvbfab
        xmcfplt       STRUCTURE mcfpltb.
  TABLES: mcpartner, *mcpartner.
  DATA: BEGIN OF mtp_vbap OCCURS 10.
          INCLUDE STRUCTURE vbapvb.
  DATA: END   OF mtp_vbap.
  DATA: BEGIN OF mtp_vblb OCCURS 10.
          INCLUDE STRUCTURE vblbvb.
  DATA: END   OF mtp_vblb.
  DATA: BEGIN OF mtp_vbep OCCURS 10.
          INCLUDE STRUCTURE vbepvb.
  DATA: END   OF mtp_vbep.
  DATA: BEGIN OF mtp_vbfa OCCURS 0.
          INCLUDE STRUCTURE vbfavb.
  DATA: END   OF mtp_vbfa.
  DATA: BEGIN OF mtp_vbup OCCURS 10.
          INCLUDE STRUCTURE vbupvb.
  DATA: END   OF mtp_vbup.
  DATA: BEGIN OF mtp_komkhie.
          INCLUDE STRUCTURE komkhie.
  DATA: END   OF mtp_komkhie.
  DATA: mtp_tabix LIKE sy-tabix.
  DATA: mtp_open_wmeng LIKE mcvbepb-wmeng.
  DATA: BEGIN OF mtp_wldat_vbep OCCURS 10,
          supkz LIKE mcvbepb-supkz,
          vbeln LIKE mcvbepb-vbeln,
          posnr LIKE mcvbepb-posnr,
          abart LIKE mcvbepb-abart,
          edatu LIKE mcvbepb-edatu,
          cmeng LIKE mcvbepb-cmeng,
          tabix LIKE sy-tabix,
        END OF mtp_wldat_vbep.
  DATA: da_alt.
  DATA: imaxhier TYPE histunr.
  DATA: savtabix LIKE sy-tabix.
* Auftragsmengen für Lieferpläne Zulieferer
  DATA: posnr_kwmeng LIKE xmcvbap-kwmeng.
* Geschäftsjahresvariante für Zulieferer/MAIS
  STATICS: da_kna1_kunnr LIKE kna1-kunnr,
           da_kna1_periv LIKE kna1-periv.

* Erzeugen alte Eintraege, wenn nichts veraendert wurde
* VBAK, VBUK, VBAP, VBUP, VBKD incl. sort
  PERFORM old_entries_prepare TABLES xmcvbak xmcvbuk xmcvbap xmcvbup
                                     xmcvbkd.
* VBEP
  LOOP AT xmcvbep WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbep-supkz.
    MODIFY xmcvbep INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbep-supkz.
    APPEND xmcvbep.
  ENDLOOP.
* VBfa
  LOOP AT xmcvbfa WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbfa-supkz.
    MODIFY xmcvbfa INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbfa-supkz.
    APPEND xmcvbfa.
  ENDLOOP.
* VBAPF
  LOOP AT xmcvbapf WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbapf-supkz.
    MODIFY xmcvbapf INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbapf-supkz.
    APPEND xmcvbapf.
  ENDLOOP.
* VBPA
  LOOP AT xmcvbpa WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbpa-supkz.
    MODIFY xmcvbpa INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbpa-supkz.
    APPEND xmcvbpa.
  ENDLOOP.
* KOMV
  LOOP AT xmckomv WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmckomv-supkz.
    MODIFY xmckomv INDEX sy-tabix.
    MOVE con_supkz_alt TO xmckomv-supkz.
    APPEND xmckomv.
  ENDLOOP.
* FPLT
  LOOP AT xmcfplt WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcfplt-supkz.
    MODIFY xmcfplt INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcfplt-supkz.
    APPEND xmcfplt.
  ENDLOOP.

* Sortieren XMC-Tabellen.
* Note 968384: XMCVBPA must be sorted by PARVW as well, because in
* form routine 'vbpap_call' it is read with binary search.
  SORT xmcvbpa by supkz mandt vbeln posnr parvw.              "<_968384
  SORT xmcvbep BY supkz mandt vbeln posnr etenr.
  SORT xmcvbfa BY supkz mandt vbelv posnv vbeln posnn vbtyp_n.
  SORT xmcvbapf BY supkz      vbeln posnr.
  SORT xmckomv BY supkz mandt knumv kposn stunr.
  SORT xmcfplt BY supkz mandt fplnr fkdat fpltr.

* es können doppelte Einträge enstehen !
  DELETE ADJACENT DUPLICATES FROM xmcfplt.
  DELETE ADJACENT DUPLICATES FROM xmcvbep.

* Ermitteln Partner fuer Kopf
  LOOP AT xmcvbak.
    CLEAR mcpartner.
    CLEAR mtp_komkhie.
    MOVE sy-tabix TO mtp_tabix.
    MOVE xmcvbak-supkz TO xmcvbpa_key-supkz.
    MOVE xmcvbak-mandt TO xmcvbpa_key-mandt.
    MOVE xmcvbak-vbeln TO xmcvbpa_key-vbeln.
    MOVE 0             TO xmcvbpa_key-posnr.
    READ TABLE xmcvbpa WITH KEY supkz = xmcvbpa_key-supkz
                                mandt = xmcvbpa_key-mandt
                                vbeln = xmcvbpa_key-vbeln
                                posnr = xmcvbpa_key-posnr BINARY SEARCH.
    IF sy-subrc EQ 0.
      LOOP AT xmcvbpa FROM sy-tabix.
        IF xmcvbpa-supkz NE xmcvbpa_key-supkz
        OR xmcvbpa-vbeln NE xmcvbpa_key-vbeln
        OR xmcvbpa-posnr NE xmcvbpa_key-posnr.
          EXIT.
        ENDIF.
        PERFORM partner_erm USING xmcvbpa mcpartner.
* Begin: Coding to use the dynamic hierarchie. see oss note 407087
*        savtabix = sy-tabix.
*        PERFORM maxhier_erm TABLES   xmcvbpa
*                            USING    xmcvbpa_key-supkz
*                                     xmcvbpa_key-vbeln
*                                     xmcvbpa_key-posnr
*                            CHANGING imaxhier.
*        READ TABLE xmcvbpa INDEX savtabix.
* End: Coding to use the dynamic hierarchie. see oss note 407087
        PERFORM kundenhier_erm USING xmcvbpa imaxhier
                               CHANGING mtp_komkhie.
      ENDLOOP.
    ENDIF.
    MOVE-CORRESPONDING mcpartner   TO xmcvbak.
    MOVE-CORRESPONDING mtp_komkhie TO xmcvbak.
    MODIFY xmcvbak INDEX mtp_tabix.
*   Ermitteln Partner fuer Position
    MOVE mcpartner TO *mcpartner.
    READ TABLE xmcvbap WITH KEY supkz = xmcvbak-supkz
                                mandt = xmcvbak-mandt
                                vbeln = xmcvbak-vbeln
                                            BINARY SEARCH.
    IF sy-subrc EQ 0.
      LOOP AT xmcvbap FROM sy-tabix.
        IF xmcvbap-supkz NE xmcvbak-supkz
        OR xmcvbap-mandt NE xmcvbak-mandt
        OR xmcvbap-vbeln NE xmcvbak-vbeln.
          EXIT.
        ENDIF.
        MOVE *mcpartner TO mcpartner.
        MOVE sy-tabix TO mtp_tabix.
        MOVE xmcvbap-supkz TO xmcvbpa_key-supkz.
        MOVE xmcvbap-mandt TO xmcvbpa_key-mandt.
        MOVE xmcvbap-vbeln TO xmcvbpa_key-vbeln.
        MOVE xmcvbap-posnr TO xmcvbpa_key-posnr.
        READ TABLE xmcvbpa WITH KEY supkz = xmcvbpa_key-supkz
                                    mandt = xmcvbpa_key-mandt
                                    vbeln = xmcvbpa_key-vbeln
                                    posnr = xmcvbpa_key-posnr
                                    BINARY SEARCH.
        IF sy-subrc EQ 0.
          LOOP AT xmcvbpa FROM sy-tabix.
            IF xmcvbpa-supkz NE xmcvbpa_key-supkz
            OR xmcvbpa-vbeln NE xmcvbpa_key-vbeln
            OR xmcvbpa-posnr NE xmcvbpa_key-posnr.
              EXIT.
            ENDIF.
            PERFORM partner_erm USING xmcvbpa mcpartner.
          ENDLOOP.
        ENDIF.
        MOVE-CORRESPONDING mcpartner TO xmcvbap.

        IF ( xmcvbak-vbklt EQ vbklt_ausl_auft      OR
             xmcvbak-vbklt EQ vbklt_ausl_auft_korr   ) AND
           xmcvbap-pkunwe NE xmcvbap-pkunag.
*         Bei MAIS-Aufträgen muß die Geschäftsjahresvariante
*         aktualisiert werden, falls ein vom AG abweichender WE
*         ermittelt wurde.
          IF xmcvbap-pkunwe NE da_kna1_kunnr.
            SELECT SINGLE kunnr periv FROM kna1
              INTO (da_kna1_kunnr, da_kna1_periv)
              WHERE kunnr EQ xmcvbap-pkunwe.
            IF sy-subrc NE 0.
              CLEAR: da_kna1_kunnr.
            ENDIF.
          ENDIF.
          IF NOT da_kna1_kunnr IS INITIAL.
            xmcvbap-periv_lf = da_kna1_periv.
          ENDIF.
        ENDIF.

        MODIFY xmcvbap INDEX mtp_tabix.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

* Ermitteln offene Mengen in den Einteilungen
  DATA: flg_schedules.
  DATA: da_fverrechnung.
  LOOP AT xmcvbak.
    READ TABLE xmcvbap WITH KEY supkz = xmcvbak-supkz
                                mandt = xmcvbak-mandt
                                vbeln = xmcvbak-vbeln
                                BINARY SEARCH.
    IF sy-subrc EQ 0.
      LOOP AT xmcvbap FROM sy-tabix.
        IF xmcvbap-supkz NE xmcvbak-supkz OR
           xmcvbap-mandt NE xmcvbak-mandt OR
           xmcvbap-vbeln NE xmcvbak-vbeln.
          EXIT.
        ENDIF.
*     Kennzeichen alte VBLB/S073 für Lieferpläne Zulieferer
        REFRESH: mtp_vblb.
        IF xmcvbap-supkz CA con_supkz_alte AND
           xmcvbak-abdis NE space.
*     Kennzeichen alte VCBLB/S073 für Lieferpläne Zulieferer
          MOVE true TO da_alt.
*     Abrufzustand alt ermitteln für LAB und FAB und PAB.
          PERFORM delivery_schedule_determine TABLES mtp_vblb
                                              USING xmcvbap-vbeln
                                                    xmcvbap-posnr
                                                    abart_lab
                                                    abart_fab
                                                    abart_pab.
        ELSE.
          CLEAR da_alt.
        ENDIF.
*     Auftragsmengen für Lieferpläne Zulieferer
        CLEAR posnr_kwmeng.
        CLEAR xmcvbap-oaume.
*
        flg_schedules = true.
        REFRESH: mtp_vbep, mtp_vbfa, mtp_vbup.
        READ TABLE xmcvbep WITH KEY supkz = xmcvbap-supkz
                                    mandt = xmcvbap-mandt
                                    vbeln = xmcvbap-vbeln
                                    posnr = xmcvbap-posnr
                                    BINARY SEARCH.
        IF sy-subrc EQ 0.
          LOOP AT xmcvbep FROM sy-tabix.
            IF xmcvbep-supkz NE xmcvbap-supkz OR
               xmcvbep-mandt NE xmcvbap-mandt OR
               xmcvbep-vbeln NE xmcvbap-vbeln OR
               xmcvbep-posnr NE xmcvbap-posnr.
              EXIT.
            ENDIF.
            MOVE-CORRESPONDING xmcvbep TO mtp_vbep. APPEND mtp_vbep.
          ENDLOOP.
        ENDIF.
        IF sy-subrc NE 0. flg_schedules = false. ENDIF.
        READ TABLE xmcvbfa WITH KEY supkz = xmcvbap-supkz
                                    mandt = xmcvbap-mandt
                                    vbelv = xmcvbap-vbeln
                                    posnv = xmcvbap-posnr
                                    BINARY SEARCH.
        IF sy-subrc EQ 0.
          LOOP AT xmcvbfa FROM sy-tabix.
            IF xmcvbfa-supkz NE xmcvbap-supkz OR
               xmcvbfa-mandt NE xmcvbap-mandt OR
               xmcvbfa-vbelv NE xmcvbap-vbeln OR
               xmcvbfa-posnv NE xmcvbap-posnr.
              EXIT.
            ENDIF.
            MOVE-CORRESPONDING xmcvbfa TO mtp_vbfa. APPEND mtp_vbfa.
          ENDLOOP.
        ENDIF.
        READ TABLE xmcvbup WITH KEY supkz = xmcvbap-supkz
                                    mandt = xmcvbap-mandt
                                    vbeln = xmcvbap-vbeln
                                    posnr = xmcvbap-posnr
                                    BINARY SEARCH.
        IF sy-subrc EQ 0.
          LOOP AT xmcvbup FROM sy-tabix.
            IF xmcvbup-supkz NE xmcvbap-supkz OR
               xmcvbup-mandt NE xmcvbap-mandt OR
               xmcvbup-vbeln NE xmcvbap-vbeln OR
               xmcvbup-posnr NE xmcvbap-posnr.
              EXIT.
            ENDIF.
            MOVE-CORRESPONDING xmcvbup TO mtp_vbup. APPEND mtp_vbup.
          ENDLOOP.
        ENDIF.
        IF sy-subrc NE 0. flg_schedules = false. ENDIF.
        IF flg_schedules EQ true.
          REFRESH mtp_vbap.
          MOVE-CORRESPONDING xmcvbap TO mtp_vbap. APPEND mtp_vbap.
          CLEAR xmcvbuk.
          READ TABLE xmcvbuk WITH KEY supkz = xmcvbap-supkz
                                      mandt = xmcvbap-mandt
                                      vbeln = xmcvbap-vbeln
                                      BINARY SEARCH.
          CLEAR da_fverrechnung.
          PERFORM get_quantity_for_update
            USING     xmcvbap-vbeln
                      xmcvbuk
            CHANGING  da_fverrechnung.
          CALL FUNCTION 'RV_SCHEDULE_CHECK_DELIVERIES'
            EXPORTING
              fbeleg                  = xmcvbak-vbeln
              fposnr                  = xmcvbap-posnr
              fverrechnung            = da_fverrechnung
              fs073_alt               = da_alt
            TABLES
              fvbap                   = mtp_vbap
              fvbfa                   = mtp_vbfa
              fvbup                   = mtp_vbup
              fvblb                   = mtp_vblb
              fxvbep                  = mtp_vbep
            EXCEPTIONS
              fehler_bei_lesen_fvbup  = 1
              fehler_bei_lesen_fxvbep = 2.
          IF sy-subrc NE 0.
            MESSAGE e812 WITH xmcvbak-vbeln sy-subrc.
          ENDIF.
          LOOP AT mtp_vbep.
            if xmcvbak-abdis NE space.
              READ TABLE xmcvbep WITH KEY supkz = xmcvbak-supkz
                                        mandt = mtp_vbep-mandt
                                        vbeln = mtp_vbep-vbeln
                                        posnr = mtp_vbep-posnr
                                        etenr = mtp_vbep-etenr
                                          edatu = mtp_vbep-edatu.
            else.
              READ TABLE xmcvbep WITH KEY supkz = xmcvbak-supkz
                                          mandt = mtp_vbep-mandt
                                          vbeln = mtp_vbep-vbeln
                                          posnr = mtp_vbep-posnr
                                          etenr = mtp_vbep-etenr
                                                       BINARY SEARCH.
            endif.
            IF sy-subrc EQ 0.
              MOVE-CORRESPONDING mtp_vbep TO xmcvbep.
*           Ermitteln Auftragsmengen für Lieferpläne Zulieferer
              IF xmcvbak-abdis NE space.
                IF xmcvbep-abart EQ abart_lab.
*               Kumulieren Auftragseingang Position nur aus LAB
                  ADD xmcvbep-swmeng TO posnr_kwmeng.
                ENDIF.
                MOVE xmcvbep-swmeng TO xmcvbep-wmeng.
                ADD  xmcvbep-olfmng TO xmcvbap-oaume.
              ENDIF.
              MODIFY xmcvbep INDEX sy-tabix.
            ELSE.
              MESSAGE e813 WITH xmcvbep1_key.
            ENDIF.
          ENDLOOP.
        ENDIF.
        IF NOT xmcvbap-kwmeng IS INITIAL.
          xmcvbap-netwr_vme = xmcvbap-netwr / xmcvbap-kwmeng.
        ELSE.
          xmcvbap-netwr_vme = 0.
        ENDIF.
*     Auftragsmengen/werte für Lieferpläne Zulieferer
        IF     xmcvbak-abdis NE space.
*         Auftragsmengen/werte für Statistikformeln speichern
*         Buffer Order quantity and net value for statistic formulas
          XMCVBAP-KWMENG_B = XMCVBAP-KWMENG.
          XMCVBAP-NETWR_B  = XMCVBAP-NETWR.

          IF NOT xmcvbap-kwmeng IS INITIAL.
          xmcvbap-netwr = posnr_kwmeng * xmcvbap-netwr / xmcvbap-kwmeng.
          xmcvbap-kzwi1 = posnr_kwmeng * xmcvbap-kzwi1 / xmcvbap-kwmeng.
          xmcvbap-kzwi2 = posnr_kwmeng * xmcvbap-kzwi2 / xmcvbap-kwmeng.
          xmcvbap-kzwi3 = posnr_kwmeng * xmcvbap-kzwi3 / xmcvbap-kwmeng.
          xmcvbap-kzwi4 = posnr_kwmeng * xmcvbap-kzwi4 / xmcvbap-kwmeng.
          xmcvbap-kzwi5 = posnr_kwmeng * xmcvbap-kzwi5 / xmcvbap-kwmeng.
          xmcvbap-kzwi6 = posnr_kwmeng * xmcvbap-kzwi6 / xmcvbap-kwmeng.
          xmcvbap-wavwr = posnr_kwmeng * xmcvbap-wavwr / xmcvbap-kwmeng.
*
          xmcvbap-brgew = posnr_kwmeng * xmcvbap-brgew / xmcvbap-kwmeng.
          xmcvbap-ntgew = posnr_kwmeng * xmcvbap-ntgew / xmcvbap-kwmeng.
          xmcvbap-volum = posnr_kwmeng * xmcvbap-volum / xmcvbap-kwmeng.
        xmcvbap-lsmeng = posnr_kwmeng * xmcvbap-lsmeng / xmcvbap-kwmeng.
        xmcvbap-kbmeng = posnr_kwmeng * xmcvbap-kbmeng / xmcvbap-kwmeng.
        xmcvbap-klmeng = posnr_kwmeng * xmcvbap-klmeng / xmcvbap-kwmeng.
          ELSE.
            xmcvbap-netwr = posnr_kwmeng * xmcvbap-netpr.
          ENDIF.
          xmcvbap-kwmeng = posnr_kwmeng.
          MODIFY xmcvbap.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

* Kopieren Wunschlieferdatum auf korrespondierende best. Einteilungen
  REFRESH mtp_wldat_vbep.
  CLEAR mtp_open_wmeng.
  SORT xmcvbep BY supkz mandt vbeln posnr abart edatu etenr.
* alle Einteilungen mit Wunschliefermenge ermitteln
  LOOP AT xmcvbep.
    CHECK xmcvbep-cmeng <> 0.
    CLEAR mtp_wldat_vbep.
    MOVE-CORRESPONDING xmcvbep TO mtp_wldat_vbep.
    MOVE sy-tabix TO mtp_wldat_vbep-tabix.
    APPEND mtp_wldat_vbep.
  ENDLOOP.
  LOOP AT mtp_wldat_vbep.
*   Übertrag bei negativer noch 'offener' Wunschliefermenge
    IF mtp_open_wmeng < 0.
      mtp_open_wmeng = mtp_open_wmeng + mtp_wldat_vbep-cmeng.
    ELSE.
      mtp_open_wmeng = mtp_wldat_vbep-cmeng.
    ENDIF.
    LOOP AT xmcvbep FROM mtp_wldat_vbep-tabix.
*     nur die bestätigten bzw. noch nicht verarbeiteten Einteilungen
      CHECK xmcvbep-bmeng <> 0 AND xmcvbep-wldatbe IS INITIAL.
*     nur solange, wie neu/alt übereinstimmt oder die Wunschliefermenge
*     durch die bereits verarbeiteten Einteilungen abgebaut ist
      IF xmcvbep-supkz <> mtp_wldat_vbep-supkz OR
         xmcvbep-vbeln <> mtp_wldat_vbep-vbeln OR
         xmcvbep-posnr <> mtp_wldat_vbep-posnr OR
         xmcvbep-abart <> mtp_wldat_vbep-abart OR
         mtp_open_wmeng <= 0.
        CLEAR mtp_open_wmeng.
        EXIT.
      ENDIF.
      xmcvbep-wldatbe = mtp_wldat_vbep-edatu.
      MODIFY xmcvbep.
*     errechne die noch 'offene' Wunschliefermenge
      mtp_open_wmeng = mtp_open_wmeng - xmcvbep-bmeng.
    ENDLOOP.
  ENDLOOP.
  SORT xmcvbep BY supkz mandt vbeln posnr etenr.
ENDFORM.                    "MC_TABLES_PREPARE1

*---------------------------------------------------------------------*
*       FORM MCINF_UPDATE_ALL                                         *
*---------------------------------------------------------------------*
*       Datenaufbereitung der Schnittstellentabellen zur Fort-        *
*       schreibung der RV-Belege                                      *
*---------------------------------------------------------------------*
FORM mcinf_update_all.
  TABLES: vbak, vbuk.
  DATA: flg_offene_werte_ermitteln.

* lies Belegkopfinformationen XMCVBAK XMCVBUK
  LOOP AT xmcvbak.
    MOVE xmcvbak-supkz TO xmcvbuk_key-supkz.
    MOVE xmcvbak-mandt TO xmcvbuk_key-mandt.
    MOVE xmcvbak-vbeln TO xmcvbuk_key-vbeln.
    READ TABLE xmcvbuk WITH KEY supkz = xmcvbuk_key-supkz
                                mandt = xmcvbuk_key-mandt
                                vbeln = xmcvbuk_key-vbeln BINARY SEARCH.
    IF sy-subrc NE ok.
      CLEAR xmcvbuk.
    ENDIF.
*   wegen Kursumrechnung von Kopffeldern VBKD-PRSDT
    MOVE xmcvbak-supkz TO xmcvbkd_key-supkz.
    MOVE xmcvbak-mandt TO xmcvbkd_key-mandt.
    MOVE xmcvbak-vbeln TO xmcvbkd_key-vbeln.
    MOVE '000000'      TO xmcvbkd_key-posnr.
    READ TABLE xmcvbkd WITH KEY supkz = xmcvbkd_key-supkz
                                mandt = xmcvbkd_key-mandt
                                vbeln = xmcvbkd_key-vbeln
                                posnr = xmcvbkd_key-posnr BINARY SEARCH.
    IF sy-subrc NE ok.
      CLEAR xmcvbkd.
    ENDIF.
    IF xmcvbkd-kursk_dat IS INITIAL.
      MOVE xmcvbkd-prsdt TO xmcvbkd-kursk_dat.
    ENDIF.
    IF xmcvbkd-kurrf_dat IS INITIAL.
      MOVE xmcvbkd-prsdt TO xmcvbkd-kurrf_dat.
    ENDIF.
*
    MOVE con_suhie_vbak TO suhie.
    IF control-logging = true.
      CLEAR mclogging.
      mclogging-vbeln = xmcvbak-vbeln.
      mclogging-stafo = xmcvbak-stafo.
      mclogging-zeitp = zeitp.
    ENDIF.
    PERFORM xmcvbak_werte USING xmcvbak xmcvbak-vbtyp.
    PERFORM update_call
      USING suhie zeitp xmcvbak-stafo flg_tmc2f.
*   lies Partnerinformationen XMCVBPA für Belegkopf
    flg_tmc2f_vbpa = true.
    MOVE xmcvbak-supkz TO xmcvbpa_key-supkz.
    MOVE xmcvbak-mandt TO xmcvbpa_key-mandt.
    MOVE xmcvbak-vbeln TO xmcvbpa_key-vbeln.
    MOVE 0             TO xmcvbpa_key-posnr.
    READ TABLE xmcvbpa WITH KEY supkz = xmcvbpa_key-supkz
                                mandt = xmcvbpa_key-mandt
                                vbeln = xmcvbpa_key-vbeln
                                posnr = xmcvbpa_key-posnr BINARY SEARCH.
    IF sy-subrc EQ 0.
      LOOP AT xmcvbpa FROM sy-tabix.
        IF xmcvbpa-supkz NE xmcvbpa_key-supkz
        OR xmcvbpa-mandt NE xmcvbpa_key-mandt
        OR xmcvbpa-vbeln NE xmcvbpa_key-vbeln
        OR xmcvbpa-posnr NE xmcvbpa_key-posnr.
          EXIT.
        ENDIF.
        IF flg_tmc2f_vbpa EQ false. EXIT. ENDIF.
        MOVE con_suhie_vbpak TO suhie.
        IF control-logging = true.
          mclogging-parvw = xmcvbpa-parvw.
        ENDIF.
        PERFORM update_call
          USING suhie zeitp xmcvbak-stafo flg_tmc2f_vbpa.
      ENDLOOP.
    ENDIF.
*   lies Positionsinformationen XMCVBAP XMCVBUP XMCVBKD
    READ TABLE xmcvbap WITH KEY supkz = xmcvbak-supkz
                                mandt = xmcvbak-mandt
                                vbeln = xmcvbak-vbeln
                                            BINARY SEARCH.
    IF sy-subrc EQ 0.
      LOOP AT xmcvbap FROM sy-tabix.
        IF xmcvbap-supkz NE xmcvbak-supkz
        OR xmcvbap-mandt NE xmcvbak-mandt
        OR xmcvbap-vbeln NE xmcvbak-vbeln.
          EXIT.
        ENDIF.
        MOVE xmcvbap-supkz TO xmcvbup_key-supkz.
        MOVE xmcvbap-mandt TO xmcvbup_key-mandt.
        MOVE xmcvbap-vbeln TO xmcvbup_key-vbeln.
        MOVE xmcvbap-posnr TO xmcvbup_key-posnr.
        READ TABLE xmcvbup WITH KEY supkz = xmcvbup_key-supkz
                                    mandt = xmcvbup_key-mandt
                                    vbeln = xmcvbup_key-vbeln
                                    posnr = xmcvbup_key-posnr
                                    BINARY SEARCH.
        IF sy-subrc NE ok.
          CLEAR xmcvbup.
        ENDIF.
        MOVE xmcvbap-supkz TO xmcvbkd_key-supkz.
        MOVE xmcvbap-mandt TO xmcvbkd_key-mandt.
        MOVE xmcvbap-vbeln TO xmcvbkd_key-vbeln.
        MOVE xmcvbap-posnr TO xmcvbkd_key-posnr.
        READ TABLE xmcvbkd WITH KEY supkz = xmcvbkd_key-supkz
                                    mandt = xmcvbkd_key-mandt
                                    vbeln = xmcvbkd_key-vbeln
                                    posnr = xmcvbkd_key-posnr
                                    BINARY SEARCH.
        IF sy-subrc NE ok.
          MOVE '000000'      TO xmcvbkd_key-posnr.
          READ TABLE xmcvbkd WITH KEY supkz = xmcvbkd_key-supkz
                                      mandt = xmcvbkd_key-mandt
                                      vbeln = xmcvbkd_key-vbeln
                                      posnr = xmcvbkd_key-posnr
                                      BINARY SEARCH.
          IF sy-subrc NE ok.
            CLEAR xmcvbkd.
          ENDIF.
        ENDIF.
        IF xmcvbkd-kursk_dat IS INITIAL.
          MOVE xmcvbkd-prsdt TO xmcvbkd-kursk_dat.
        ENDIF.
        IF xmcvbkd-kurrf_dat IS INITIAL.
          MOVE xmcvbkd-prsdt TO xmcvbkd-kurrf_dat.
        ENDIF.
        MOVE xmcvbap-supkz TO xmcvbapf_key-supkz.
        MOVE xmcvbap-vbeln TO xmcvbapf_key-vbeln.
        MOVE xmcvbap-posnr TO xmcvbapf_key-posnr.
        READ TABLE xmcvbapf WITH KEY supkz = xmcvbapf_key-supkz
                                     vbeln = xmcvbapf_key-vbeln
                                     posnr = xmcvbapf_key-posnr
                                     BINARY SEARCH.
        IF sy-subrc NE 0. CLEAR xmcvbapf. ENDIF.
*       Ermitteln OAUME, OAUWE, OLIME, OLIKW
        CLEAR erlmenge_f.
        PERFORM offene_werte_erm TABLES xmcfplt
                                 USING  xmcvbak
                                        xmcvbup
                                        xmcvbapf
                                        xmcvbkd
                                 CHANGING xmcvbap.
        MOVE con_suhie_vbap TO suhie.
        IF control-logging = true.
          mclogging-posnr = xmcvbap-posnr.
          mclogging-stafo = xmcvbap-stafo.
          CLEAR mclogging-parvw.
        ENDIF.
        PERFORM xmcvbap_werte USING xmcvbap xmcvbak-vbtyp.
        PERFORM update_call
          USING suhie zeitp xmcvbap-stafo flg_tmc2f.
        PERFORM komv_call USING con_suhie_komv.
*       lies Einteilungsinformationen XMCVBEP
        flg_tmc2f_vbep = true.
        flg_tmc2f_vbpa = true.
        flg_tmc2f_komv = true.
        flg_tmc2f_fplt = true.
        READ TABLE xmcvbep WITH KEY supkz = xmcvbap-supkz
                                    mandt = xmcvbap-mandt
                                    vbeln = xmcvbap-vbeln
                                    posnr = xmcvbap-posnr
                                    BINARY SEARCH.
        IF sy-subrc EQ 0.
          LOOP AT xmcvbep FROM sy-tabix.
            IF xmcvbep-supkz NE xmcvbap-supkz
            OR xmcvbep-mandt NE xmcvbap-mandt
            OR xmcvbep-vbeln NE xmcvbap-vbeln
            OR xmcvbep-posnr NE xmcvbap-posnr.
              EXIT.
            ENDIF.
            IF  flg_tmc2f_vbep EQ false
            AND flg_tmc2f_vbpa EQ false
            AND flg_tmc2f_komv EQ false.
              EXIT.
            ENDIF.
            MOVE con_suhie_vbep TO suhie.
            IF control-logging = true.
              mclogging-etenr = xmcvbep-etenr.
            ENDIF.
            IF ( NOT xmcvbep-bsart IS INITIAL OR
             ( NOT xmcvbep-bdart IS INITIAL AND
               NOT xmcvbep-plart IS INITIAL ) ) and
* In case of CRM order go to ELSE branch, besides X, Z and A scenario
* same logic as in LV07A001
             ( xmcvbak-vbkla(2)   NE 'CR' OR
               xmcvbak-vbkla+2(1) EQ 'X'  OR
               xmcvbak-vbkla+2(1) EQ 'Z'  OR
               xmcvbak-vbkla+2(1) EQ 'A' ).
              IF NOT xmcvbep-bsart IS INITIAL AND
                     xmcvbak-supkz CA con_supkz_neue.
*               Bestellanforderung
                IF xmcvbuk-cmgst CA 'B'.
                  MOVE-CORRESPONDING xmcvbak TO vbak.
                  MOVE-CORRESPONDING xmcvbuk TO vbuk.
                  CALL FUNCTION 'SD_ORDER_SUBSEQUENT_ALLOWED'
                    EXPORTING
                      bvbak                   = vbak
                      bvbuk                   = vbuk
                      fofun                   = '02'  "Banf
                    EXCEPTIONS
                      error                   = 01
                      warning                 = 02
                      error_but_do_not_delete = 03.
                  IF     sy-subrc      NE 0             AND
                         control-modus EQ con_modus_sim AND
                         control-srout NE 'DBL_'        AND
                         xmcvbep-olfmng IS INITIAL      AND
                         xmcvbup-absta  CA ' A'         AND
                         xmcvbap-lsmeng GT xmcvbap-kbmeng.
*                   Wenn Reservierung zurückgenommen wird und
*                   Prüfung und keine Kreditneuvergabe
                    MOVE xmcvbep-wmeng TO xmcvbep-olfmng.
                  ENDIF.
                ENDIF.
              ENDIF.
              PERFORM offene_werte_eint USING    xmcvbep xmcvbap.
*                                       CHANGING XMCVBEP.
            ELSE.
*     Dienstleistungen, die lieferrelevant sind, sollen bei Kredit-
*     sperre keinen offenen Auftragswert absetzen, aber beim Prüfen
*     des Kreditlimits für den aktuellen Beleg ist der offene Auf-
*     tragswert aufzubauen.
              flg_offene_werte_ermitteln = true.
              IF xmcvbuk-cmgst CA 'B'.
                MOVE-CORRESPONDING xmcvbak TO vbak.
*     After the clearing of VBAK-VBKLA, the system will take the order
*     as a R/3 order. Furthermore, the behaviour of credit consuming of
*     the CRM order will be same as the one of R/3 order.
                CLEAR VBAK-VBKLA.
                MOVE-CORRESPONDING xmcvbuk TO vbuk.
                CALL FUNCTION 'SD_ORDER_SUBSEQUENT_ALLOWED'
                  EXPORTING
                    bvbak                   = vbak
                    bvbuk                   = vbuk
                    fofun                   = '01'
                  EXCEPTIONS
                    error                   = 01
                    warning                 = 02
                    error_but_do_not_delete = 03.
                IF sy-subrc NE 0.
*                 Reservierung zurücknehmen
                  IF control-modus NE con_modus_sim.
*                   normale Fortschreibung
                    CLEAR flg_offene_werte_ermitteln.
                  ELSEIF control-srout EQ 'DBL_'.
*                   Ermitteln offene Werte bei Kreditneuvergabe
                    CLEAR flg_offene_werte_ermitteln.
                  ELSE.
*                   Simulationsmodus (Prüfmodus)
                    IF xmcvbak-supkz CA con_supkz_alte.
*                     nur für den neuen Belegzustand
                      CLEAR flg_offene_werte_ermitteln.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ENDIF.
              IF NOT flg_offene_werte_ermitteln IS INITIAL.
                PERFORM offene_werte_eint USING    xmcvbep xmcvbap.
*                                         CHANGING XMCVBEP.
              ENDIF.
            ENDIF.
*           Ermitteln offene Liefermenge pro Einteilung (geliefert und
*           noch nicht fakturiert)
            IF xmcvbep-vsmng GE erlmenge_f.
              xmcvbep-ofamng = xmcvbep-vsmng - erlmenge_f.
              erlmenge_f = 0.
            ELSE.
              xmcvbep-ofamng = 0.
              erlmenge_f = erlmenge_f - xmcvbep-vsmng.
            ENDIF.
            IF erlmenge_f LT 0. CLEAR erlmenge_f. ENDIF.
*           Ende
            PERFORM xmcvbep_werte USING xmcvbap
                                        xmcvbep xmcvbuk-vbtyp.
            IF flg_tmc2f_vbep EQ true.
              PERFORM update_call
                USING suhie zeitp xmcvbap-stafo flg_tmc2f_vbep.
            ENDIF.
*           lies Konditionen XMCKOMV mit Einteilungen
            PERFORM komv_call USING con_suhie_vbepkomv.
*           lies Partnerinformationen XMCVBPA mit Einteilungen
            PERFORM vbpap_call USING con_suhie_vbpape.
            IF control-logging = true.
              CLEAR mclogging-parvw.
            ENDIF.
          ENDLOOP.
        ENDIF.
*       lies Partnerinformationen XMCVBPA ohne Einteilungen
        IF control-logging = true.
          CLEAR mclogging-etenr.
        ENDIF.
        PERFORM vbpap_call USING con_suhie_vbpap.
*       Termine des Fakturierungsplans
        PERFORM fplt_call USING con_suhie_fplt.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

* Update Datenbanktabelle aus interner Tabelle
  CHECK control-logging NE true.

  PERFORM perform_on_commit_aktiv USING control-modus
                                        mcinf-low
                                        flg_verbuchung
                             CHANGING sy-subrc.
  IF sy-subrc = 4.
    PERFORM update_from_int ON COMMIT.
  ELSE.
    PERFORM update_from_int.
  ENDIF.

ENDFORM.                    "MCINF_UPDATE_ALL


*---------------------------------------------------------------------*
*       FORM OFFENE_WERTE_EINT                                        *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  OWE_MCVBEP                                                    *
*  -->  OWE_MCVBAP                                                    *
*---------------------------------------------------------------------*
FORM offene_werte_eint   USING    owe_mcvbep STRUCTURE mcvbepb
                                  owe_mcvbap STRUCTURE mcvbapb.
*                        CHANGING OWE_MCVBEP STRUCTURE MCVBEPB.
  owe_mcvbep-oeime = owe_mcvbep-olfmng.
  PERFORM cmpre_calculate(saplvkmp)
    USING    owe_mcvbap-cmpre
             owe_mcvbap-cmpre_flt
             owe_mcvbep-olfmng
             owe_mcvbep-abges
    CHANGING owe_mcvbep-oeikw
             owe_mcvbep-oeikwges
             owe_mcvbep-oeikwaa.
ENDFORM.                    "OFFENE_WERTE_EINT

*---------------------------------------------------------------------*
*       FORM OFFENE_WERTE_ERM                                         *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  OW_MCVBUP                                                     *
*  -->  OW_MCVBAPF                                                    *
*  -->  OW_MCVBAP                                                     *
*---------------------------------------------------------------------*
FORM offene_werte_erm TABLES   ow_mcfplt  STRUCTURE mcfpltb
                      USING    ow_mcvbak  STRUCTURE mcvbakb
                               ow_mcvbup  STRUCTURE mcvbupb
                               ow_mcvbapf STRUCTURE mcvbafb
                               ow_mcvbkd  STRUCTURE mcvbkdb
                      CHANGING ow_mcvbap  STRUCTURE mcvbapb.
  LOCAL: ow_mcvbapf-remng.
  LOCAL: ow_mcvbup-fksaa.

* Differential billing switch, statics for performance.     "v 1882256
* Initialised with 'I' different from the valid values
* ' ' and 'X'.
  STATICS: sv_bill_diff_active        TYPE char1 value 'I'. "^ 1882256

  DATA: owe_erlmenge_l LIKE vbapf-erlmenge_l. "in VME
  DATA: owe_erlmenge_f LIKE vbapf-erlmenge_f. "in VME
  DATA: lv_remng       LIKE ow_mcvbapf-remng.
  DATA: lv_wemng       LIKE ow_mcvbapf-wemng.
  DATA: owe_cmpre_flt LIKE vbap-cmpre_flt.
  DATA: flg_offene_werte_ermitteln.
  DATA: flg_reset_olimeau.
  DATA: wa_tvau  like tvau.
  DATA: da_index LIKE sy-index.
  DATA: ls_xmcvbfa LIKE xmcvbfa,
        ls_t691k   LIKE t691k.
  DATA: ls_vbup LIKE vbup.
  DATA: flg_third_party.
  DATA: lv_cred_val_nf_done   TYPE xfeld VALUE ' '.         "v 1882256
  DATA: lv_cred_val_nf        TYPE mcvbapb-olikw.
  DATA: lv_abges              TYPE mcvbapb-abges.           "^ 1882256

* Differential billing: One call for performance reasons.   "v 1882256
  IF sv_bill_diff_active = 'I'.
    sv_bill_diff_active = cl_sd_bill_switch_check=>sd_sfws_bill_diff_1( ).
  ENDIF.                                                    "^ 1882256
*
  IF NOT ow_mcvbap-kzfme IS INITIAL.
*   Wirkstoff
    owe_erlmenge_l = ow_mcvbapf-erlmengelv.
    ow_mcvbapf-remng = ow_mcvbapf-remngv.
  ELSE.
    owe_erlmenge_l = ow_mcvbapf-erlmenge_l.
    IF ow_mcvbap-vrkme NE ow_mcvbap-meins.
      PERFORM lagermenge_betrag        "hier Verkaufsmenge
        USING    xmcvbap-meins
                 xmcvbap-vrkme
                 xmcvbap-umvkn
                 xmcvbap-umvkz
                 ow_mcvbapf-erlmenge_l
        CHANGING owe_erlmenge_l.
      IF NOT ow_mcvbapf-remng IS INITIAL.
        lv_remng = ow_mcvbapf-remng.
        PERFORM lagermenge_betrag      "hier Verkaufsmenge
          USING    xmcvbap-meins
                   xmcvbap-vrkme
                   xmcvbap-umvkn
                   xmcvbap-umvkz
                   lv_remng
          CHANGING ow_mcvbapf-remng.
      ENDIF.
      IF NOT ow_mcvbapf-wemng IS INITIAL.
        lv_wemng = ow_mcvbapf-wemng.
        PERFORM lagermenge_betrag      "hier Verkaufsmenge
          USING    xmcvbap-meins
                   xmcvbap-vrkme
                   xmcvbap-umvkn
                   xmcvbap-umvkz
                   lv_wemng
          CHANGING ow_mcvbapf-wemng.
      ENDIF.
    ENDIF.
  ENDIF.
*
  IF NOT ow_mcvbak-abdis IS INITIAL.
*   Im Zuliefererfall wird die OAUME schon im TABLES_PREPARE gefüllt
    CLEAR: ow_mcvbap-oauwe.
    IF NOT ow_mcvbap-kwmeng IS INITIAL.
      ow_mcvbap-oauwe = ow_mcvbap-oaume *
                      ( ow_mcvbap-netwr / ow_mcvbap-kwmeng ).
    ENDIF.
  ELSE.
    CLEAR: ow_mcvbap-oaume, ow_mcvbap-oauwe.
* clear: ow_mcvbap-oaukw, ow_mcvbap-oaukwaa, ow_mcvbap-oaukwges.
    IF ow_mcvbup-lfgsa CA 'AB'
    AND ow_mcvbap-lsmeng > owe_erlmenge_l.
      ow_mcvbap-oaume = ow_mcvbap-lsmeng - owe_erlmenge_l.
      IF NOT ow_mcvbap-kwmeng IS INITIAL.
        ow_mcvbap-oauwe = ow_mcvbap-oaume *
                        ( ow_mcvbap-netwr / ow_mcvbap-kwmeng ).
      ENDIF.
*   if not ow_mcvbap-lfrel is initial.
*     flg_offene_werte_ermitteln = true.
*     if xmcvbuk-cmgst ca 'B'.
*       move-corresponding xmcvbak to vbak.
*       move-corresponding xmcvbuk to vbuk.
*       call function 'SD_ORDER_SUBSEQUENT_ALLOWED'
*            exporting
*                 bvbak   = vbak
*                 bvbuk   = vbuk
*                 fofun   = '01'
*            exceptions
*                 error   = 01
*                 warning = 02.
*       if sy-subrc ne 0.
*         Reservierung zurücknehmen
*         if control-modus ne con_modus_sim.
*           normale Fortschreibung
*           clear flg_offene_werte_ermitteln.
*         elseif control-srout eq 'DBL_'.
*            Ermitteln offene Werte bei Kreditneuvergabe
*           clear flg_offene_werte_ermitteln.
*         else.
*           Simulationsmodus (Prüfmodus)
*           if xmcvbak-supkz ca con_supkz_alte.
*             nur für den neuen Belegzustand
*             clear flg_offene_werte_ermitteln.
*           endif.
*         endif.
*       endif.
*     endif.
*     if not flg_offene_werte_ermitteln is initial.
*       perform cmpre_calculate(saplvkmp)
*        using    ow_mcvbap-cmpre
*                 ow_mcvbap-cmpre_flt
*                 ow_mcvbap-oaume
*                 ow_mcvbap-abges
*        changing ow_mcvbap-oaukw
*                 ow_mcvbap-oaukwges
*                 ow_mcvbap-oaukwaa.
*     endif.
*   endif.
    ENDIF.
  ENDIF.
* offene Liefermenge, offener Lieferwert
  CLEAR:
    ow_mcvbap-olime,
    ow_mcvbap-olikw,
    ow_mcvbap-olikwges,
    ow_mcvbap-olikwaa,
    ow_mcvbap-olimeau,
    ow_mcvbap-olikwau,
    ow_mcvbap-olikwauges,
    ow_mcvbap-olikwauaa.

* nur, wenn überhaupt fakturarelevant aber nicht Proforma
  CHECK NOT ow_mcvbap-fkrel IS INITIAL AND
            ow_mcvbap-fkrel CN con_fkrel_proform.

* Bei auftragsbezogener Faktura gemäß RE-Menge und Kredit sitzt der
* Fakturastatus auf SPACE, obwohl Fakturen kommen werden, sobald
* RE-Menge vorhanden ist.
  IF ow_mcvbap-fkrel     EQ charf   AND
     ow_mcvbup-fksaa     EQ space   AND
     ow_mcvbup-gbsta     CA 'AB'    AND
     ow_mcvbap-abgru     IS INITIAL.
    ow_mcvbup-fksaa = chara.
  ENDIF.

  IF NOT ow_mcvbap-kzfme IS INITIAL.
*   Wirkstoff
    owe_erlmenge_f = ow_mcvbapf-faklmengv.
  ELSE.
    owe_erlmenge_f = ow_mcvbapf-faklmeng.
  ENDIF.

  IF NOT ow_mcvbap-shkzg IS INITIAL.
*   Retoure
    IF NOT ow_mcvbap-kzfme IS INITIAL AND
       ow_mcvbapf-faklmengv IS INITIAL.
*     Wirkstoff
      owe_erlmenge_f = ow_mcvbapf-omengev - ow_mcvbapf-smengev.
    ELSEIF ow_mcvbapf-faklmeng IS INITIAL.
      owe_erlmenge_f = ow_mcvbapf-omenge - ow_mcvbapf-smenge.
    ENDIF.
  ENDIF.
* direkter Bezug
  IF ow_mcvbup-fksaa CA 'ABC'.
    IF NOT ow_mcvbap-kzfme IS INITIAL.
*     Wirkstoff
      owe_erlmenge_f = ow_mcvbapf-erlmengefv.
    ELSE.
      owe_erlmenge_f = ow_mcvbapf-erlmenge_f.
    ENDIF.
  ENDIF.
  IF ow_mcvbap-vrkme NE ow_mcvbap-meins AND
     ow_mcvbap-kzfme IS INITIAL.
    PERFORM lagermenge_betrag          "hier Verkaufsmenge
      USING    xmcvbap-meins
               xmcvbap-vrkme
               xmcvbap-umvkn
               xmcvbap-umvkz
               owe_erlmenge_f
      CHANGING owe_erlmenge_f.
  ENDIF.
*
ENHANCEMENT-SECTION     OFFENE_WERTE_ERM_03 SPOTS ES_SAPLMCS1.
  IF owe_erlmenge_l GE owe_erlmenge_f AND
     ow_mcvbak-abdis IS INITIAL.
*   darf nicht negativ werden
    ow_mcvbap-olime = owe_erlmenge_l - owe_erlmenge_f.
    ls_xmcvbfa-abges = ow_mcvbap-abges.
    IF ow_mcvbap-olime GT 0 AND
       ow_mcvbap-fkrel CA con_fkrel_lieferbez.
*   Payment cards shall not be affected (use mcvbap-abges)
      PERFORM ABSICHERUNGSFORM_LESEN(SAPLVKMP)
              USING ow_mcvbap-abfor
              CHANGING ls_t691k.
      IF ls_t691k-abstp NE '3'.
*   ABGES for quantity OLIME must be determined from the deliveries
        READ TABLE xmcvbfa WITH KEY
                   supkz = ow_mcvbap-supkz
                   mandt = ow_mcvbap-mandt
                   vbelv = ow_mcvbap-vbeln
                   posnv = ow_mcvbap-posnr
                   BINARY SEARCH.
        IF sy-subrc EQ 0.
          CLEAR: ls_xmcvbfa.
          LOOP AT xmcvbfa FROM sy-tabix
             WHERE stufe EQ 0.      "nur direkte Nachfolger
            check cl_sd_doc_category_util=>is_delivery_outgoing( xmcvbfa-vbtyp_n ).
            IF xmcvbfa-supkz NE ow_mcvbap-supkz OR
               xmcvbfa-mandt NE ow_mcvbap-mandt OR
               xmcvbfa-vbelv NE ow_mcvbap-vbeln OR
               xmcvbfa-posnv NE ow_mcvbap-posnr.
              EXIT.
            ENDIF.
* only open deliveries should be taken in account
              CALL FUNCTION 'SD_VBUP_SELECT'
                EXPORTING
                  i_document_number = xmcvbfa-vbeln
                  i_item_number     = xmcvbfa-posnn
                IMPORTING
                  E_VBUP            = ls_vbup
                EXCEPTIONS
                  ITEM_NOT_FOUND    = 1
                  ERROR_MESSAGE     = 2.
              IF sy-subrc NE 0.
                CLEAR ls_vbup.   "delivery already archived -> no update
              ELSE.
                IF ls_vbup-fksta = 'C'.
                CONTINUE.
                ENDIF.
              ENDIF.
              ls_xmcvbfa-abges = ls_xmcvbfa-abges
                               + xmcvbfa-rfmng * xmcvbfa-abges.
            ls_xmcvbfa-rfmng = ls_xmcvbfa-rfmng + xmcvbfa-rfmng.
          ENDLOOP.
          ls_xmcvbfa-abges = ls_xmcvbfa-abges / ls_xmcvbfa-rfmng.
        ENDIF.
      ENDIF.
    ENDIF.

*   LEB (Lieferempfangsbestätigung) / POD (Proof of Delivery)
*   Bei FKREL lieferbezogen ohne Nullmenge ist die Lieferung erledigt,
*   wenn durch die LEB die Liefermenge auf Null geht - der Faktura
*   status wird zurückgenommen (FKSTA = ' ') -> kein offener Lieferwert
    IF ow_mcvbap-olime GT 0 AND
       ow_mcvbap-fkrel CA con_fkrel_lfbz_keine_nullmg
       AND ow_mcvbap-xchpf NE 'X'.
      READ TABLE xmcvbfa WITH KEY
                 supkz = ow_mcvbap-supkz
                 mandt = ow_mcvbap-mandt
                 vbelv = ow_mcvbap-vbeln
                 posnv = ow_mcvbap-posnr
                 BINARY SEARCH.
* Teilmenge ist bereits fakturiert.
      if not owe_erlmenge_f  is initial.
       ow_mcvbap-olime = owe_erlmenge_l.
      endif.

      LOOP AT xmcvbfa FROM sy-tabix
                      WHERE stufe EQ 0.      "nur direkte Nachfolger
        check cl_sd_doc_category_util=>is_delivery_outgoing( xmcvbfa-vbtyp_n ).
        CHECK xmcvbfa-supkz EQ ow_mcvbap-supkz AND
              xmcvbfa-mandt EQ ow_mcvbap-mandt AND
              xmcvbfa-vbelv EQ ow_mcvbap-vbeln AND
              xmcvbfa-posnv EQ ow_mcvbap-posnr.
        CALL FUNCTION 'SD_VBUP_SELECT'
          EXPORTING
            i_document_number       = xmcvbfa-vbeln
            i_item_number           = xmcvbfa-posnn
          IMPORTING
            E_VBUP                  = ls_vbup
          EXCEPTIONS
            ITEM_NOT_FOUND          = 1
            ERROR_MESSAGE           = 2.
        IF sy-subrc NE 0.
          CLEAR ls_vbup.   "delivery already archived -> no update
        ELSE.
        IF ( ls_vbup-fksta = space and ls_vbup-pdsta = charc ) or
           ls_vbup-fksta = 'C'.
*         rfmng ist in BasisME -> umrechnen in VRKME falls nötig
          IF ow_mcvbap-vrkme NE ow_mcvbap-meins AND
             ow_mcvbap-kzfme IS INITIAL.
            PERFORM lagermenge_betrag
                    USING    xmcvbfa-meins
                             ow_mcvbap-vrkme
                             ow_mcvbap-umvkn
                             ow_mcvbap-umvkz
                             xmcvbfa-rfmng
                    CHANGING xmcvbfa-rfmng.
          ENDIF.
          ow_mcvbap-olime = ow_mcvbap-olime - xmcvbfa-rfmng.
        ENDIF.
       ENDIF.
      ENDLOOP.
    ENDIF.

*   OW_MCVBAP-OLIKW = OW_MCVBAP-OLIME * OWE_CMPRE_FLT.
    PERFORM cmpre_calculate(saplvkmp)
      USING    ow_mcvbap-cmpre
               ow_mcvbap-cmpre_flt
               ow_mcvbap-olime
               ls_xmcvbfa-abges
      CHANGING ow_mcvbap-olikw
               ow_mcvbap-olikwges
               ow_mcvbap-olikwaa.

*   Differential billing: OLIKW* have to be reduced by the  "v 1882256
*   credit value contained in non-final billing documents.
*   Non-final billing documents do not contribute to
*   ERLMENGE_F. So up to here OLIKW* assumes the delivery
*   is unbillled.
    IF sv_bill_diff_active = abap_true.
      PERFORM diff_cred_values_adjust TABLES   xmcvbfa
                                      USING    ow_mcvbup
                                               '1'  "For OLIKW* fields
                                               ls_xmcvbfa-abges
                                      CHANGING lv_cred_val_nf_done
                                               lv_cred_val_nf
                                               ow_mcvbap.
    ENDIF.                                                  "^ 1882256

  ENDIF.
END-ENHANCEMENT-SECTION.
*$*$-Start: OFFENE_WERTE_ERM_03-----------------------------------------------------------------$*$*
ENHANCEMENT 4  OIA_SAPLMCS1.    "active version
*NOTE 1248406
*CSM 21-N0v-2008, Solution to rush order as per suggestions from Christof,
*OLIKW should be calculated only when OLIME is not zero
* Note 1324341  n_1687996 the test on OLIME should only be done for orders that are with immediate delivery
* this is defined in TVAK-LISOF this should also not be done in RVKRED07 for Rush order
* (when LISOF is not initial)

*********beginning of note 1324341 n_1687996
DATA: BEGIN OF lt_tvak OCCURS 10.
          INCLUDE STRUCTURE tvak.
DATA: END OF lt_tvak.
DATA: l_nodelivery type c.
DATA: l_lisof type c."n_1392345

**********begininning of note 2006292
DATA : ls_contract_reval TYPE boolean VALUE abap_false.
**********end of note 2006292

DATA: ls_vbfa TYPE MCVBFAB,
      ls_vbrk    TYPE vbrk.
* n_1392345
* first Check if this is an idoc related
* sales order with immediate delivery
* Check if TAS G_OIKIMPORT-LISOF has been
* setup in Function OIK_SD_CALLOFF_DELIVERY_CREATE
IMPORT l_lisof FROM MEMORY ID 'OIK_DELIVERY_LISOF'. "n_1392345

 IF l_lisof IS INITIAL. "n_1392345

CALL FUNCTION 'MCV_TVAK_READ'
  EXPORTING
    I_AUART         = ow_mcvbak-auart
  TABLES
    T_TVAK          =  lt_tvak
 EXCEPTIONS
   NOT_FOUND       = 1
   OTHERS          = 2.

   read table lt_tvak index 1.
             .
  IF SY-SUBRC <> 0.
  MESSAGE ID 'VT' TYPE 'E' NUMBER '356'
         WITH ow_mcvbak-auart.
  ENDIF.
  MOVE lt_tvak-lisof TO l_lisof.   "n_1392345
 ENDIF.

* IF  NOT lt_tvak-lisof IS initial "n_1392345
  IF NOT l_lisof IS INITIAL        "n_1392345
     AND NOT ( sy-cprog = 'RVKRED07' or sy-cprog = 'UKM_RVKRED07' ).
    IF owe_erlmenge_l GE owe_erlmenge_f AND
     ow_mcvbak-abdis is initial.

     ow_mcvbap-olime = owe_erlmenge_l - owe_erlmenge_f.

    ENDIF.
* check ow_mcvbap-olime GT 0.
    IF ow_mcvbap-olime <= 0.
    l_nodelivery = 'X'.
    ENDIF.

endif.

 IF l_nodelivery IS initial.

**********begininning of note 2006292
"for contract revaluation check if we have invoice already created.
"Note: 2216146: Ensuring note 2006292 for non-SD differential invoice scenario alone
READ TABLE xmcvbfa[] INTO ls_vbfa with KEY vbtyp_n = 'M'.
IF ls_vbfa IS NOT INITIAL.

  SELECT SINGLE * FROM vbrk INTO ls_vbrk
  WHERE vbeln = ls_vbfa-vbeln
    AND fktyp = 'N'.

  IF sy-subrc EQ 0.
  LS_CONTRACT_REVAL = abap_true.
endif.

ENDIF.
"End of note: 2216146
**********end of note 2006292


******* end of note 1324341 n_1687996
  IF ( NOT OW_MCVBAP-CMETH IS INITIAL AND LS_CONTRACT_REVAL eq abap_false ). "2006292

 PERFORM oi_offene_werte_erm_del_qci "1248406
    TABLES   ow_mcfplt
             xmcvbfa
             xmcvbuk
             xmcvbup
    USING    ow_mcvbak
             ow_mcvbup
             ow_mcvbapf
             ow_mcvbkd
    CHANGING ow_mcvbap  .

ELSEIF ( OWE_ERLMENGE_L GE OWE_ERLMENGE_F AND
*NOTE 1248406
     ow_mcvbak-abdis IS INITIAL ) OR LS_CONTRACT_REVAL eq abap_true. "2006292
*   darf nicht negativ werden
    ow_mcvbap-olime = owe_erlmenge_l - owe_erlmenge_f.
    ls_xmcvbfa-abges = ow_mcvbap-abges.
    IF ow_mcvbap-olime GT 0 AND
       ow_mcvbap-fkrel CA con_fkrel_lieferbez.
*   Payment cards shall not be affected (use mcvbap-abges)
      PERFORM ABSICHERUNGSFORM_LESEN(SAPLVKMP)
              USING ow_mcvbap-abfor
              CHANGING ls_t691k.
      IF ls_t691k-abstp NE '3'.
*   ABGES for quantity OLIME must be determined from the deliveries
        READ TABLE xmcvbfa WITH KEY
                   supkz = ow_mcvbap-supkz
                   mandt = ow_mcvbap-mandt
                   vbelv = ow_mcvbap-vbeln
                   posnv = ow_mcvbap-posnr
                   BINARY SEARCH.
        IF sy-subrc EQ 0.
          CLEAR: ls_xmcvbfa.
          LOOP AT xmcvbfa FROM sy-tabix
             WHERE VBTYP_N IN cl_sd_doc_category_util=>rg_delivery_outgoing( )
                   AND stufe EQ 0.      "nur direkte Nachfolger "1708949
            IF xmcvbfa-supkz NE ow_mcvbap-supkz OR
               xmcvbfa-mandt NE ow_mcvbap-mandt OR
               xmcvbfa-vbelv NE ow_mcvbap-vbeln OR
               xmcvbfa-posnv NE ow_mcvbap-posnr.
              EXIT.
            ENDIF.

*start of n_1637462
* only open deliveries should be taken in account
              CALL FUNCTION 'SD_VBUP_SELECT'
                EXPORTING
                  i_document_number = xmcvbfa-vbeln
                  i_item_number     = xmcvbfa-posnn
                IMPORTING
                  E_VBUP            = ls_vbup
                EXCEPTIONS
                  ITEM_NOT_FOUND    = 1                "1708949
                  ERROR_MESSAGE     = 2.               "1708949
              IF sy-subrc NE 0.                        "1708949
                CLEAR ls_vbup.   "delivery already archived -> no update
              ELSE.
                IF ls_vbup-fksta = 'C'.
                CONTINUE.
                ENDIF.
              ENDIF.
*end of  n_1637462

            ls_xmcvbfa-abges = ls_xmcvbfa-abges
                               + xmcvbfa-rfmng * xmcvbfa-abges.
            ls_xmcvbfa-rfmng = ls_xmcvbfa-rfmng + xmcvbfa-rfmng.
          ENDLOOP.
          ls_xmcvbfa-abges = ls_xmcvbfa-abges / ls_xmcvbfa-rfmng.
        ENDIF.
      ENDIF.
    ENDIF.

*   LEB (Lieferempfangsbestätigung) / POD (Proof of Delivery)
*   Bei FKREL lieferbezogen ohne Nullmenge ist die Lieferung erledigt,
*   wenn durch die LEB die Liefermenge auf Null geht - der Faktura
*   status wird zurückgenommen (FKSTA = ' ') -> kein offener Lieferwert
    IF ow_mcvbap-olime GT 0 AND
       ow_mcvbap-fkrel CA con_fkrel_lfbz_keine_nullmg
       AND ow_mcvbap-xchpf NE 'X'.        "n_2009454
      READ TABLE xmcvbfa WITH KEY
                 supkz = ow_mcvbap-supkz
                 mandt = ow_mcvbap-mandt
                 vbelv = ow_mcvbap-vbeln
                 posnv = ow_mcvbap-posnr
                 BINARY SEARCH.
"Start note 1568351 (core note 1499960)
* Teilmenge ist bereits fakturiert.
      if not owe_erlmenge_f  is initial.
       ow_mcvbap-olime = owe_erlmenge_l.
      endif.
"End note 1568351 (core note 1499960)
      LOOP AT xmcvbfa FROM sy-tabix
                      WHERE vbtyp_n IN cl_sd_doc_category_util=>rg_delivery_outgoing( )
                        AND stufe EQ 0.      "nur direkte Nachfolger
        CHECK xmcvbfa-supkz EQ ow_mcvbap-supkz AND
              xmcvbfa-mandt EQ ow_mcvbap-mandt AND
              xmcvbfa-vbelv EQ ow_mcvbap-vbeln AND
              xmcvbfa-posnv EQ ow_mcvbap-posnr.
        CALL FUNCTION 'SD_VBUP_SELECT'
          EXPORTING
            i_document_number       = xmcvbfa-vbeln
            i_item_number           = xmcvbfa-posnn
          IMPORTING
            E_VBUP                  = ls_vbup
          EXCEPTIONS
            ITEM_NOT_FOUND          = 1          "1708949
            ERROR_MESSAGE           = 2.         "1708949
        IF sy-subrc NE 0.                        "1708949
          CLEAR ls_vbup.   "delivery already archived -> no update
        ELSE.
"Start note 1568351 (core note 1499960)
        IF ( ls_vbup-fksta = space and ls_vbup-pdsta = charc ) or  "1708949
           ls_vbup-fksta = 'C'.
"End note 1568351 (core note 1499960)
*         rfmng ist in BasisME -> umrechnen in VRKME falls nötig
          IF ow_mcvbap-vrkme NE ow_mcvbap-meins AND
             ow_mcvbap-kzfme IS INITIAL.
            PERFORM lagermenge_betrag
                    USING    xmcvbfa-meins
                             ow_mcvbap-vrkme
                             ow_mcvbap-umvkn
                             ow_mcvbap-umvkz
                             xmcvbfa-rfmng
                    CHANGING xmcvbfa-rfmng.
          ENDIF.
          ow_mcvbap-olime = ow_mcvbap-olime - xmcvbfa-rfmng.
        ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.

*   OW_MCVBAP-OLIKW = OW_MCVBAP-OLIME * OWE_CMPRE_FLT.
    PERFORM cmpre_calculate(saplvkmp)
      USING    ow_mcvbap-cmpre
               ow_mcvbap-cmpre_flt
               ow_mcvbap-olime
               ls_xmcvbfa-abges
      CHANGING ow_mcvbap-olikw
               ow_mcvbap-olikwges
               ow_mcvbap-olikwaa.

*   Differential billing: OLIKW* have to be reduced by the  "v 1882256
*   credit value contained in non-final billing documents.
*   Non-final billing documents do not contribute to
*   ERLMENGE_F. So up to here OLIKW* assumes the delivery
*   is unbillled.
    IF sv_bill_diff_active = abap_true.
      PERFORM diff_cred_values_adjust TABLES   xmcvbfa
                                      USING    ow_mcvbup
                                               '1'  "For OLIKW* fields
                                               ls_xmcvbfa-abges
                                      CHANGING lv_cred_val_nf_done
                                               lv_cred_val_nf
                                               ow_mcvbap.
    ENDIF.                                                  "^ 1882256

  ENDIF.
  ENDIF.
*CSM 21-N0v-2008
ENDENHANCEMENT.
*$*$-End:   OFFENE_WERTE_ERM_03-----------------------------------------------------------------$*$*

* offene Liefermenge, offener Lieferwert aus Auftrag
* OLIMEAU wird nur dann ermittelt, wenn es auch im nachfolgenden
* benötigt wird (Achtung: redundantes Coding)
  IF ow_mcvbup-fksaa CA   'AB'         OR
     ow_mcvbup-lfgsa CA   'AB'         OR
     ( ow_mcvbup-fksaa CA ' ' AND
       ow_mcvbup-lfgsa CA 'C'      ).
    PERFORM auftragsmenge_ermitteln USING  ow_mcvbup-fksaa
                                           ow_mcvbup-fksta
                                           ow_mcvbap-fkrel
                                           ow_mcvbap-lsmeng
                                           ow_mcvbap-kwmeng
                                           ow_mcvbap-zmeng
                                           ow_mcvbapf-remng
                                           ow_mcvbapf-wemng
                                  CHANGING ow_mcvbap-olimeau.
  ENDIF.

* Wenn Strecke und gesperrt, Zurücknahme des off. Lieferwertes
* Ermitteln, ob Strecke im Spiel
* A C H T U N G: es kann sein, daß XMCVBEP nicht gefüllt ist, da
*                SUHIE = Position
  IF ow_mcvbap-fkrel     CA 'B'     AND
     OW_MCVBUP-FKSAA     CA 'AB'    AND
     ow_mcvbup-lfgsa     EQ space   AND
     ow_mcvbup-gbsta     CA 'AB'    AND
     OW_MCVBAP-ABGRU     IS INITIAL.
    READ TABLE xmcvbep WITH KEY supkz = ow_mcvbap-supkz
                                mandt = ow_mcvbap-mandt
                                vbeln = ow_mcvbap-vbeln
                                posnr = ow_mcvbap-posnr BINARY SEARCH.
    IF sy-subrc         EQ 0 AND
      NOT xmcvbep-bsart IS INITIAL.
    ELSE.
      CLEAR xmcvbep-bsart.
    ENDIF.
  ENDIF.
*
  IF ( ow_mcvbap-fkrel   EQ charf      OR
       ( ow_mcvbap-fkrel CA 'B'  AND
         NOT xmcvbep-bsart IS INITIAL ) ) AND
     OW_MCVBUP-FKSAA     CA 'AB'          AND
     ow_mcvbup-lfgsa     EQ space         AND
     ow_mcvbup-gbsta     CA 'AB'          AND
     ow_mcvbap-abgru     IS INITIAL       AND
     ow_mcvbap-kwmeng    GT ow_mcvbap-kbmeng.
    MOVE charx TO flg_third_party.
    IF xmcvbuk-cmgst CA 'B'.
      MOVE-CORRESPONDING xmcvbak TO vbak.
      MOVE-CORRESPONDING xmcvbuk TO vbuk.
      CALL FUNCTION 'SD_ORDER_SUBSEQUENT_ALLOWED'
        EXPORTING
          bvbak                   = vbak
          bvbuk                   = vbuk
          fofun                   = '02'         "Banf
        EXCEPTIONS
          error                   = 01
          warning                 = 02
          error_but_do_not_delete = 03.
      IF     sy-subrc      NE 0              AND
           ( xmcvbak-supkz CA con_supkz_alte OR
             control-modus NE con_modus_sim  OR
             control-srout EQ 'DBL_' ).
*       nicht löschen wenn schon bestellt (Banf nicht mehr löschbar)
        IF OW_MCVBAP-KBMENG EQ 0.
          CLEAR OW_MCVBAP-OLIMEAU.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.

* Wenn Fakturierung auftragsbezogen, Rücknahme des off. Lieferwertes
ENHANCEMENT-SECTION     OFFENE_WERTE_ERM_01 SPOTS ES_SAPLMCS1.
* Strecke ausschließen, da oben schon behandelt
  IF ( ( OW_MCVBAP-FKREL     CA 'B'    AND
         FLG_THIRD_PARTY IS INITIAL )  OR
       OW_MCVBAP-FKREL     CA  'I'    OR
*      Begin ENHO AD_BOS_01_SAPLMCS1, IS-ADEC-BOQ, Bill of Service
*      OW_MCVBAP-FKREL     CA  'I'   ) AND
       OW_MCVBAP-FKREL     CA  'I'    OR
       OW_MCVBAP-FKREL     CA CON_FKREL_DP  ) AND " IS-4.6, payment
*      End ENHO AD_BOS_01_SAPLMCS1, IS-ADEC-BOQ,
     ow_mcvbup-lfgsa     CA 'A '.
    IF xmcvbuk-cmgst CA 'B'.
      MOVE-CORRESPONDING xmcvbak TO vbak.
      MOVE-CORRESPONDING xmcvbuk TO vbuk.
      CALL FUNCTION 'SD_ORDER_SUBSEQUENT_ALLOWED'
        EXPORTING
          bvbak                   = vbak
          bvbuk                   = vbuk
          fofun                   = '01'         "bestätigte Menge
        EXCEPTIONS
          error                   = 01
          warning                 = 02
          error_but_do_not_delete = 03.
      IF     sy-subrc      NE 0              AND
           ( xmcvbak-supkz CA con_supkz_alte OR
             control-modus NE con_modus_sim  OR
             control-srout EQ 'DBL_' ).
        CLEAR ow_mcvbap-olimeau.
        MOVE charx TO flg_reset_olimeau.
      ENDIF.
    ENDIF.
  ENDIF.
END-ENHANCEMENT-SECTION.

* offener Lieferwert nur dann, wenn auch fakturiert wird
  IF ow_mcvbup-fksaa CA 'AB' OR
     ow_mcvbup-lfgsa CA 'AB'.
*   wenn auftragsbezogen fakturiert wird oder noch nicht endausgeliefert
    IF ow_mcvbap-olimeau GE owe_erlmenge_f.
*     darf nicht negativ werden
      ow_mcvbap-olimeau = ow_mcvbap-olimeau - owe_erlmenge_f.
*     OW_MCVBAP-OLIKWAU = OW_MCVBAP-OLIMEAU * OWE_CMPRE_FLT.
      PERFORM cmpre_calculate(saplvkmp)
        USING    ow_mcvbap-cmpre
                 ow_mcvbap-cmpre_flt
                 ow_mcvbap-olimeau
                 ow_mcvbap-abges
*                OW_MCVBAPF-ABGES
        CHANGING ow_mcvbap-olikwau
                 ow_mcvbap-olikwauges
                 ow_mcvbap-olikwauaa.
*     Differential billing: Analogous to OLIKW* above,      "v 1882256
*     OLIKWAU* are reduced by the credit value contained
*     within non-final billing documents.
      IF sv_bill_diff_active = abap_true.
*       LV_ABGES introduced to avoid OW_MCVBAP USING and CHANGING.
        lv_abges = ow_mcvbap-abges.
        PERFORM diff_cred_values_adjust TABLES   xmcvbfa
                                        USING    ow_mcvbup
                                                 '2'  "For OLIKWAU* fields
                                                 lv_abges
                                        CHANGING lv_cred_val_nf_done
                                                 lv_cred_val_nf
                                                 ow_mcvbap.
      ENDIF.                                                "^ 1882256

* Sonderbehandlung bei Nachberechnung:
      IF NOT ow_mcvbak-augru IS INITIAL.
        SELECT SINGLE * FROM tvau INTO wa_tvau
                       WHERE augru = ow_mcvbak-augru.
        IF sy-subrc EQ 0 AND wa_tvau-vauna EQ 1.
          CLEAR OW_MCVBAP-OLIKWAU.
          CLEAR OW_MCVBAP-OLIKWAUGES.
          CLEAR OW_MCVBAP-OLIKWAUAA.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDIF.
  IF ow_mcvbup-fksaa CA ' ' AND
     ow_mcvbup-lfgsa CA 'C'.
*   wenn lieferbezogen fakturiert und endausgeliefert
    IF owe_erlmenge_l GE owe_erlmenge_f.
*     darf nicht negativ werden
      ow_mcvbap-olimeau = owe_erlmenge_l - owe_erlmenge_f.
      ow_mcvbap-olikwau = ow_mcvbap-olimeau * owe_cmpre_flt.
      PERFORM cmpre_calculate(saplvkmp)
        USING    ow_mcvbap-cmpre
                 ow_mcvbap-cmpre_flt
                 ow_mcvbap-olimeau
                 ow_mcvbap-abges
*                OW_MCVBAPF-ABGES
        CHANGING ow_mcvbap-olikwau
                 ow_mcvbap-olikwauges
                 ow_mcvbap-olikwauaa.
*     Differential billing: Analogous to OLIKW* above,      "v 1882256
*     OLIKWAU* are reduced by the credit value contained
*     within non-final billing documents.
      IF sv_bill_diff_active = abap_true.
*       LV_ABGES introduced to avoid OW_MCVBAP USING and CHANGING.
        lv_abges = ow_mcvbap-abges.
        PERFORM diff_cred_values_adjust TABLES   xmcvbfa
                                        USING    ow_mcvbup
                                                 '2'  "For OLIKWAU* fields
                                                 lv_abges
                                        CHANGING lv_cred_val_nf_done
                                                 lv_cred_val_nf
                                                 ow_mcvbap.
      ENDIF.                                                "^ 1882256
    ENDIF.
  ENDIF.


* Periodische oder Teilfakturierung
ENHANCEMENT-SECTION     OFFENE_WERTE_ERM_02 SPOTS ES_SAPLMCS1.
"{ Begin ENHO AD_BOS_01_SAPLMCS1 IS-EC-BOS ECO_BOS }
* IBU A&D/E&C, bill of service (BOS) IS-ADEC-BOQ
* IF ow_mcvbap-fkrel   CA 'I'     AND
  IF ( OW_MCVBAP-FKREL   CA 'I'     OR
       OW_MCVBAP-FKREL   CA CON_FKREL_DP ) AND
"{ End ENHO AD_BOS_01_SAPLMCS1 IS-EC-BOS ECO_BOS }
     OW_MCVBUP-FKSAA   CA 'AB'    AND
     flg_reset_olimeau IS INITIAL.
    PERFORM cmpre_determine(saplvkmp)
      USING ow_mcvbap-cmpre
            ow_mcvbap-cmpre_flt
      CHANGING owe_cmpre_flt.
    ow_mcvbap-olikwau = owe_cmpre_flt.
    ow_mcvbap-olinwau = ow_mcvbap-netwr.
*   bei Teilfaktura wird, wenn ein Termin vorhanden ist, der Kreditwert
*   aus der Summer der Termine ermittelt.
    READ TABLE ow_mcfplt WITH KEY supkz = ow_mcvbkd-supkz
                                  mandt = ow_mcvbkd-mandt
                                  fplnr = ow_mcvbkd-fplnr
                                  BINARY SEARCH
                                  TRANSPORTING NO FIELDS.
    LOOP AT ow_mcfplt FROM sy-tabix.
      IF ow_mcfplt-supkz <> ow_mcvbkd-supkz OR
         ow_mcfplt-mandt <> ow_mcvbkd-mandt OR
         ow_mcfplt-fplnr <> ow_mcvbkd-fplnr.
        EXIT.
      ENDIF.

      IF ow_mcfplt-fareg NA con_fareg_periodisch.
        ADD 1 TO da_index.
        IF da_index EQ 1.
          CLEAR ow_mcvbap-olikwau.
          CLEAR ow_mcvbap-olinwau.
        ENDIF.
        IF ow_mcfplt-fareg NA con_fareg_anzahlungen.
          IF NOT ow_mcfplt-fproz IS INITIAL.
            ow_mcvbap-olikwau = ow_mcvbap-olikwau +
              ( owe_cmpre_flt   *  ( ow_mcfplt-fproz / 100 ) ).
            ow_mcvbap-olinwau = ow_mcvbap-olinwau +
              ( ow_mcvbap-netwr *  ( ow_mcfplt-fproz / 100 ) ).
          ELSE.
            IF ow_mcvbap-netwr IS INITIAL.
              ow_mcvbap-olikwau = ow_mcvbap-olikwau +
             ( ow_mcvbap-cmpre *  ow_mcfplt-fakwr ).
              ow_mcvbap-olinwau = ow_mcvbap-olinwau + ow_mcfplt-fakwr.
            ELSE.
              ow_mcvbap-olikwau = ow_mcvbap-olikwau +
             ( owe_cmpre_flt   *
                    ( ow_mcfplt-fakwr / ow_mcvbap-netwr ) ).
              ow_mcvbap-olinwau = ow_mcvbap-olinwau + ow_mcfplt-fakwr.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
*
      IF ow_mcfplt-fksaf EQ 'C'.
        IF ow_mcfplt-fareg CA con_fareg_periodisch.
          PERFORM cmpre_determine(saplvkmp)
            USING ow_mcfplt-cmpre
                  ow_mcfplt-cmpre_flt
            CHANGING ow_mcfplt-cmpre_flt.
          ow_mcvbap-olikwau = ow_mcvbap-olikwau - ow_mcfplt-cmpre_flt.
          ow_mcvbap-olinwau = ow_mcvbap-olinwau - ow_mcfplt-fakwr.
        ELSE.
          IF ow_mcfplt-fareg NA con_fareg_anzahlungen.
            IF NOT ow_mcfplt-fproz IS INITIAL.
              ow_mcvbap-olikwau = ow_mcvbap-olikwau -
                ( owe_cmpre_flt   *  ( ow_mcfplt-fproz / 100 ) ).
              ow_mcvbap-olinwau = ow_mcvbap-olinwau -
                ( ow_mcvbap-netwr *  ( ow_mcfplt-fproz / 100 ) ).
            ELSE.
              IF ow_mcvbap-netwr IS INITIAL.
                ow_mcvbap-olikwau = ow_mcvbap-olikwau -
               ( ow_mcvbap-cmpre *  ow_mcfplt-fakwr ).
                ow_mcvbap-olinwau = ow_mcvbap-olinwau - ow_mcfplt-fakwr.
              ELSE.
                ow_mcvbap-olikwau = ow_mcvbap-olikwau -
               ( owe_cmpre_flt   *
                     ( ow_mcfplt-fakwr / ow_mcvbap-netwr ) ).
                ow_mcvbap-olinwau = ow_mcvbap-olinwau - ow_mcfplt-fakwr.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

*   offene Liefermenge, offener Lieferwert aus Auftrag
    PERFORM auftragsmenge_ermitteln USING    ow_mcvbup-fksaa
                                             ow_mcvbup-fksta
                                             ow_mcvbap-fkrel
                                             ow_mcvbap-lsmeng
                                             ow_mcvbap-kwmeng
                                             ow_mcvbap-zmeng
                                             ow_mcvbapf-remng
                                             ow_mcvbapf-wemng
                                    CHANGING ow_mcvbap-olimeau.
*   OW_MCVBAP-OLIKWAU = OW_MCVBAP-OLIMEAU * OW_MCVBAP-OLIKWAU.
    owe_cmpre_flt = ow_mcvbap-olikwau.
    PERFORM cmpre_calculate(saplvkmp)
      USING    owe_cmpre_flt
               owe_cmpre_flt
               ow_mcvbap-olimeau
               ow_mcvbap-abges
*              OW_MCVBAPF-ABGES
      CHANGING ow_mcvbap-olikwau
               ow_mcvbap-olikwauges
               ow_mcvbap-olikwauaa.

* Sonderbehandlung bei Nachberechnung:
    IF NOT ow_mcvbak-augru IS INITIAL.
      SELECT SINGLE * FROM tvau INTO wa_tvau
                      WHERE augru = ow_mcvbak-augru.
      IF sy-subrc EQ 0 AND wa_tvau-vauna EQ 1.
        CLEAR OW_MCVBAP-OLIKWAU.
        CLEAR OW_MCVBAP-OLIKWAUGES.
        CLEAR OW_MCVBAP-OLIKWAUAA.
      ENDIF.
    ENDIF.
  ENDIF.
END-ENHANCEMENT-SECTION.

  erlmenge_f = owe_erlmenge_f.
ENDFORM.                    "OFFENE_WERTE_ERM

*---------------------------------------------------------------------*
*       FORM PROSA_setzen                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  us_xvbap                                                      *
*  -->  ch_prosa                                                      *
*---------------------------------------------------------------------*
FORM prosa_setzen USING    us_xvbap STRUCTURE vbapvb
                  CHANGING ch_prosa TYPE prosa.

* bei Produktselektion mit Ergebnis = B (Substitutionsgrund) muß
* VBAP-PROSA umgeschossen werden
  CHECK ch_prosa EQ charb.
  CHECK NOT us_xvbap-sugrd IS INITIAL.
  IF us_xvbap-sugrd NE tvsu-sugrd.
    SELECT SINGLE * FROM tvsu WHERE sugrd EQ us_xvbap-sugrd.
  ENDIF.
  IF tvsu-suerg EQ charb.
    CLEAR ch_prosa.
  ENDIF.

ENDFORM.                    "PROSA_SETZEN

*---------------------------------------------------------------------*
*       FORM CHECK_PROSA                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  IV_SUGRD                                                      *
*  -->  CV_PROSA                                                      *
*---------------------------------------------------------------------*
form check_prosa using    iv_sugrd type sugrd
                 changing cv_prosa type prosa.

* If product selection results as B (reason for substitution), we
* have to clear VBAP-PROSA
  if cv_prosa ne charb   or
     iv_sugrd IS INITIAL.
    return.
  endif.
  if iv_sugrd ne tvsu-sugrd.
    select single *
           from tvsu
           where sugrd eq iv_sugrd.
  endif.
  if tvsu-suerg eq charb.
    clear cv_prosa.
  endif.

endform.                    "CHECK_PROSA

*---------------------------------------------------------------------*
*       FORM UPDATE_CALL                                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM update_call USING uc_suhie TYPE suhie
                       uc_zeitp TYPE dzeitp
                       uc_stafo TYPE stafo
                       uc_tmc2f TYPE c.

  LOCAL: xmcvbak-supkz.
* Broadcasting
  DATA: bc_active.
*
  control-zeitp = uc_zeitp.
  uc_tmc2f = false.
  PERFORM retoure_erm
    USING    xmcvbuk-vbtyp uc_suhie xmcvbap-shkzg
    CHANGING rc.
  IF rc EQ true.                       "Retoure etc.
    IF xmcvbak-supkz EQ con_supkz_alt.
      xmcvbak-supkz = con_supkz_alt_pos.
    ELSE.
      xmcvbak-supkz = con_supkz_neu_neg.
    ENDIF.
  ENDIF.

* Füllen BW-Extraktionsstrukturen
  IF flg_bw EQ true           AND
     flg_verbuchung EQ con_d  AND
     UC_SUHIE CA 'ANOPT'      AND
     control-modus CA con_modus_bw.
    DATA: xs_active.
    SET EXTENDED CHECK OFF.            " Für Syntax-Check ohne Plug-In
    CALL FUNCTION 'MCEX_FILL_XS_11'
      EXPORTING
        suhie                = uc_suhie
        XMCKOMV              = XMCKOMV
        xmcvbak              = xmcvbak
        xmcvbap              = xmcvbap
        xmcvbapf             = xmcvbapf
        xmcvbep              = xmcvbep
        xmcvbkd              = xmcvbkd
        xmcvbuk              = xmcvbuk
        xmcvbup              = xmcvbup
        XMCFPLT              = XMCFPLT
        INTERFACE_VERSION_11 = CON_BW_EX_11_INTERFACE_VERSION
      IMPORTING
        xs_active            = xs_active.
    SET EXTENDED CHECK ON.
    IF xs_active = true.
      uc_tmc2f = true.
    ENDIF.
  ENDIF.                                                    " BW
* Fill Broadcast Container
  IF cl_ops_switch_check=>sd_sfws_gb_01( ) = abap_true AND
     flg_gb EQ true           AND
     flg_verbuchung EQ con_d  AND
     uc_suhie CA 'ANOPT'      AND
     control-modus CA con_modus_gb.
    CALL FUNCTION 'MCV_BROADCAST_COLLECT_SLS'
      EXPORTING
        suhie                = uc_suhie
        xmckomv              = xmckomv
        xmcvbak              = xmcvbak
        xmcvbap              = xmcvbap
        xmcvbapf             = xmcvbapf
        xmcvbep              = xmcvbep
        xmcvbfa              = xmcvbfa[]
        xmcvbkd              = xmcvbkd
        xmcvbpa              = xmcvbpa[]
        xmcvbuk              = xmcvbuk
        xmcvbup              = xmcvbup
      IMPORTING
        bc_active            = bc_active.
    IF bc_active = true.
      uc_tmc2f = true.
    ENDIF.
  ENDIF.                                                    " GB
*
  IF uc_suhie EQ con_suhie_vbak.
    CALL FUNCTION 'MCV_STATISTICS_SYSTEMSEQUENCES'
      EXPORTING
        zeitp  = uc_zeitp
        mcvbak = xmcvbak
      TABLES
        stafos = int_stafos.
    MOVE uc_stafo TO int_stafos-stafo.
    APPEND int_stafos. SORT int_stafos.
  ELSEIF uc_suhie EQ con_suhie_vbap.
    CALL FUNCTION 'MCV_STATISTICS_SYSTEMSEQUENCES'
      EXPORTING
        zeitp  = uc_zeitp
        mcvbak = xmcvbak
        mcvbap = xmcvbap
      TABLES
        stafos = int_stafos.
    MOVE uc_stafo TO int_stafos-stafo.
    APPEND int_stafos. SORT int_stafos.
  ENDIF.
  READ TABLE int_stafos INDEX 1.
*
  IF control-modus EQ con_modus_norm
  AND control-logging NE true.
*   ermittle alle Fortschreibungsregeln
    MOVE xmcvbak-mandt       TO tmc2f_key-mandt.
    MOVE uc_zeitp            TO tmc2f_key-zeitp.
    MOVE uc_suhie            TO tmc2f_key-suhie.
    MOVE int_stafos-stafo    TO tmc2f_key-stafo.
    MOVE flg_verbuchung TO tmc2f_key-kbtch.
    READ TABLE int_tmc2f WITH KEY mandt = tmc2f_key-mandt
                                  zeitp = tmc2f_key-zeitp
                                  suhie = tmc2f_key-suhie
                                  stafo = tmc2f_key-stafo
                                  kbtch = tmc2f_key-kbtch
                         BINARY SEARCH.
    IF sy-subrc LE 4.
      LOOP AT int_tmc2f FROM sy-tabix.
        CHECK int_tmc2f-mandt EQ tmc2f_key-mandt
        AND   int_tmc2f-zeitp EQ tmc2f_key-zeitp
        AND   int_tmc2f-suhie EQ tmc2f_key-suhie
        AND   int_tmc2f-kbtch EQ tmc2f_key-kbtch.
        CLEAR                   tmcb-mandt.
        MOVE int_tmc2f-stafo TO tmcb-stafo.
        READ TABLE int_stafos WITH KEY mandt = tmcb-mandt
                                       stafo = tmcb-stafo
                              BINARY SEARCH.
        CHECK sy-subrc EQ 0.
        uc_tmc2f = true.
        prog_tab-fprog = int_tmc2f-fprog.

        READ TABLE prog_tab WITH KEY fprog = prog_tab-fprog.
        IF sy-subrc NE 0.
*    Verknüpfung der common parts
          CALL FUNCTION 'MCS_LOAD_UPDATE_RULES_LIS'
            EXPORTING
              progname = int_tmc2f-fprog.
          APPEND prog_tab-fprog TO prog_tab.
        ENDIF.

*       rufe Update_Routine in jeweiligem Modulpool auf
        PERFORM (int_tmc2f-frout) IN PROGRAM (prog_tab-fprog)
          TABLES mclogging
          USING  xmckomv
                 xmcvbak
                 xmcvbap
                 xmcvbep
                 xmcvbkd
                 xmcvbpa
                 xmcvbuk
                 xmcvbup
                 xmcvbapf
                 xmcfplt
                 control.
      ENDLOOP.
    ENDIF.
  ELSE.
    MOVE xmcvbak-mandt      TO tmc2f2_key-mandt.
    MOVE uc_zeitp           TO tmc2f2_key-zeitp.
    MOVE uc_suhie           TO tmc2f2_key-suhie.
    MOVE int_stafos-stafo   TO tmc2f2_key-stafo.
    READ TABLE int_tmc2f WITH KEY mandt = tmc2f2_key-mandt
                                  zeitp = tmc2f2_key-zeitp
                                  suhie = tmc2f2_key-suhie
                                  stafo = tmc2f2_key-stafo
                         BINARY SEARCH.
    IF sy-subrc LE 4.
      LOOP AT int_tmc2f FROM sy-tabix.
        CHECK int_tmc2f-mandt EQ tmc2f2_key-mandt
        AND   int_tmc2f-zeitp EQ tmc2f2_key-zeitp
        AND   int_tmc2f-suhie EQ tmc2f2_key-suhie.
        CLEAR                   tmcb-mandt.
        MOVE int_tmc2f-stafo TO tmcb-stafo.
        READ TABLE int_stafos WITH KEY mandt = tmcb-mandt
                                       stafo = tmcb-stafo
                              BINARY SEARCH.
        CHECK sy-subrc EQ 0.
        uc_tmc2f = true.
        prog_tab-fprog = int_tmc2f-fprog.
        IF control-logging EQ true.
          CLEAR: mclogging-data, mclogging-key, mclogging-date,
                 mclogging-unit.
          MOVE int_stafos-stafo     TO mclogging-stafo.
          mclogging-gstru  = int_tmc2f-fprog+4(4).
          mclogging-frout  = int_tmc2f-frout.
          mclogging-supkz  = xmcvbak-supkz.
          mclogging-reason = con_reason_prep.
          APPEND mclogging.
        ENDIF.

        READ TABLE prog_tab WITH KEY fprog = prog_tab-fprog.
        IF sy-subrc NE 0.
*    Verknüpfung der common parts
          CALL FUNCTION 'MCS_LOAD_UPDATE_RULES_LIS'
            EXPORTING
              progname = int_tmc2f-fprog.
          IF control-logging NE true.
            APPEND prog_tab-fprog TO prog_tab.
          ENDIF.
        ENDIF.

*       rufe Update_Routine in jeweiligem Modulpool auf
        PERFORM (int_tmc2f-frout) IN PROGRAM (prog_tab-fprog)
          TABLES mclogging
          USING  xmckomv
                 xmcvbak
                 xmcvbap
                 xmcvbep
                 xmcvbkd
                 xmcvbpa
                 xmcvbuk
                 xmcvbup
                 xmcvbapf
                 xmcfplt
                 control.
      ENDLOOP.
    ENDIF.
  ENDIF.
ENDFORM.                    "UPDATE_CALL


*---------------------------------------------------------------------*
*       FORM UPDATE_FROM_INT                                          *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM update_from_int.

* START NOTE 376750
* select is performance uncritical as tmc2p is completely buffered
  LOOP AT prog_tab.
    SELECT SINGLE mcinf FROM tmc2p INTO prog_tab-mcinf
                        WHERE fprog = prog_tab-fprog.
    MODIFY prog_tab.
  ENDLOOP.
*
  SORT prog_tab BY mcinf fprog.
* END NOTE 376750

* zuerst den Standard-Update der Info-Strukturen
  LOOP AT prog_tab.
    CASE control-modus.
      WHEN con_modus_norm.
        PERFORM (mcinf_update_form) IN PROGRAM (prog_tab-fprog)
          USING control.
      WHEN con_modus_new.
        PERFORM (mcinf_update_form) IN PROGRAM (prog_tab-fprog)
          USING control.
      WHEN con_modus_sim.
        PERFORM (simulation) IN PROGRAM (prog_tab-fprog)
          USING control.
      WHEN con_modus_sim_new.
        PERFORM (simulation) IN PROGRAM (prog_tab-fprog)
          USING control.
    ENDCASE.
  ENDLOOP.

* evtl. Update für event-driven Early Warning System
  IF control-modus = con_modus_norm.
    LOOP AT prog_tab.
      CALL FUNCTION 'MC_EXCEPTION_EVENT'
        EXPORTING
          fprog            = prog_tab-fprog
        IMPORTING
          vrsia            = control-vrsio
        EXCEPTIONS
          no_event_analyse = 01.
      IF sy-subrc = 0.
        PERFORM (mcinf_update_form) IN PROGRAM (prog_tab-fprog)
          USING control.
      ENDIF.
    ENDLOOP.
  ENDIF.

* refresh auf die interne Tabellen der Info-Strukturen
  LOOP AT prog_tab.
    PERFORM inttab_refresh IN PROGRAM (prog_tab-fprog)
      USING control.
  ENDLOOP.

  CLEAR prog_tab. REFRESH prog_tab.
ENDFORM.                    "UPDATE_FROM_INT


*---------------------------------------------------------------------*
*       FORM VBPAP_CALL                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  VC_SUHIE                                                      *
*---------------------------------------------------------------------*
FORM vbpap_call USING vc_suhie TYPE suhie.
  flg_tmc2f_vbpa = true.
* Kopfpartner
  MOVE xmcvbap-supkz TO xmcvbpa_key-supkz.
  MOVE xmcvbap-mandt TO xmcvbpa_key-mandt.
  MOVE xmcvbap-vbeln TO xmcvbpa_key-vbeln.
  MOVE 0             TO xmcvbpa_key-posnr.
  READ TABLE xmcvbpa WITH KEY supkz = xmcvbpa_key-supkz
                              mandt = xmcvbpa_key-mandt
                              vbeln = xmcvbpa_key-vbeln
                              posnr = xmcvbpa_key-posnr
                              BINARY SEARCH.
  IF sy-subrc EQ 0.
    LOOP AT xmcvbpa FROM sy-tabix.
      IF flg_tmc2f_vbpa EQ false. EXIT. ENDIF.
      IF xmcvbpa-supkz NE xmcvbpa_key-supkz
      OR xmcvbpa-mandt NE xmcvbpa_key-mandt
      OR xmcvbpa-vbeln NE xmcvbpa_key-vbeln
      OR xmcvbpa-posnr NE xmcvbpa_key-posnr.
        EXIT.
      ENDIF.
*     gibt es dazu einen Positionspartner ?
      MOVE xmcvbpa-supkz TO xmcvbpa2_key-supkz.
      MOVE xmcvbpa-mandt TO xmcvbpa2_key-mandt.
      MOVE xmcvbpa-vbeln TO xmcvbpa2_key-vbeln.
      MOVE xmcvbap-posnr TO xmcvbpa2_key-posnr.
      MOVE xmcvbpa-parvw TO xmcvbpa2_key-parvw.
      READ TABLE xmcvbpa WITH KEY supkz = xmcvbpa2_key-supkz
                                  mandt = xmcvbpa2_key-mandt
                                  vbeln = xmcvbpa2_key-vbeln
                                  posnr = xmcvbpa2_key-posnr
                                  parvw = xmcvbpa2_key-parvw
                                  BINARY SEARCH.
      IF sy-subrc NE 0.
        IF control-logging EQ true.
          MOVE xmcvbpa-parvw TO mclogging-parvw.
        ENDIF.
        PERFORM update_call
          USING vc_suhie zeitp xmcvbap-stafo flg_tmc2f_vbpa.
      ENDIF.
    ENDLOOP.
  ENDIF.
* Positionspartner
  CHECK flg_tmc2f_vbpa EQ true.
  MOVE xmcvbap-supkz TO xmcvbpa_key-supkz.
  MOVE xmcvbap-mandt TO xmcvbpa_key-mandt.
  MOVE xmcvbap-vbeln TO xmcvbpa_key-vbeln.
  MOVE xmcvbap-posnr TO xmcvbpa_key-posnr.
  READ TABLE xmcvbpa WITH KEY supkz = xmcvbpa_key-supkz
                              mandt = xmcvbpa_key-mandt
                              vbeln = xmcvbpa_key-vbeln
                              posnr = xmcvbpa_key-posnr BINARY SEARCH.
  IF sy-subrc EQ 0.
    LOOP AT xmcvbpa FROM sy-tabix.
      IF flg_tmc2f_vbpa EQ false. EXIT. ENDIF.
      IF xmcvbpa-supkz NE xmcvbpa_key-supkz
      OR xmcvbpa-mandt NE xmcvbpa_key-mandt
      OR xmcvbpa-vbeln NE xmcvbpa_key-vbeln
      OR xmcvbpa-posnr NE xmcvbpa_key-posnr.
        EXIT.
      ENDIF.
      IF control-logging EQ true.
        MOVE xmcvbpa-parvw TO mclogging-parvw.
      ENDIF.
      PERFORM update_call
        USING vc_suhie zeitp xmcvbap-stafo flg_tmc2f_vbpa.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "VBPAP_CALL

*---------------------------------------------------------------------*
*       FORM ZEITPUNKT_AUFTRAG_ERMITTELN                              *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  US_TRVOG                                                      *
*  -->  CH_ZEITP                                                      *
*---------------------------------------------------------------------*
FORM zeitpunkt_auftrag_ermitteln USING us_trvog TYPE trvog
                                       us_vbak  STRUCTURE vbak
                                       us_vbuk  STRUCTURE vbukvb
                                 CHANGING ch_zeitp TYPE dzeitp.
  CASE us_trvog.
    WHEN '0'.
      ch_zeitp = con_zeitp_auftrag.
    WHEN '1'.
      ch_zeitp = con_zeitp_anfrage.
    WHEN '2'.
      ch_zeitp = con_zeitp_angebot.
    WHEN '3'.
      ch_zeitp = con_zeitp_auftrag.
    WHEN '4'.
      ch_zeitp = con_zeitp_angebot.
      CALL FUNCTION 'SD_DETERMINE_CONTRACT_TYPE'
        EXPORTING
          i_vbak_vbeln      = us_vbak-vbeln
          i_vbuk            = us_vbuk
          i_vbak            = us_vbak
        EXCEPTIONS
          service_contract  = 1
          quantity_contract = 2.
*               NO_CONTRACT        = 3
*               DOCUMENT_NOT_FOUND = 4
*               OTHERS             = 5.
      IF sy-subrc EQ 1.
        ch_zeitp = con_zeitp_auftrag.
      ENDIF.
  ENDCASE.
ENDFORM.                    "ZEITPUNKT_AUFTRAG_ERMITTELN


*---------------------------------------------------------------------*
*       FORM OLD_ENTRIES_PREPARE                                       *
*---------------------------------------------------------------------*
* Erzeugen alte Eintraege, wenn nichts veraendert wurde
*---------------------------------------------------------------------*
*  <--  Ymcvbak   Auftragkopftabelle
*  <--  xmcvbuk   Auftragkopfstatustabelle
*  <--  xmcvbap   Auftragpositionstabelle
*  <--  xmcvbup   Auftragpositionsstatustabelle
*  <--  xmcvbkd   Auftragpositions Kaufmmaenische Daten
*----------------------------------------------------------------------*
FORM old_entries_prepare TABLES xmcvbak STRUCTURE mcvbakb
                                xmcvbuk STRUCTURE mcvbukb
                                xmcvbap STRUCTURE mcvbapb
                                xmcvbup STRUCTURE mcvbupb
                                xmcvbkd STRUCTURE mcvbkdb.
* VBAK
  LOOP AT xmcvbak WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbak-supkz.
    MODIFY xmcvbak INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbak-supkz.
    APPEND xmcvbak.
  ENDLOOP.
* VBAP
  LOOP AT xmcvbap WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbap-supkz.
    MODIFY xmcvbap INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbap-supkz.
    APPEND xmcvbap.
  ENDLOOP.
* VBUK
  LOOP AT xmcvbuk WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbuk-supkz.
    MODIFY xmcvbuk INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbuk-supkz.
    APPEND xmcvbuk.
  ENDLOOP.
* VBUP
  LOOP AT xmcvbup WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbup-supkz.
    MODIFY xmcvbup INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbup-supkz.
    APPEND xmcvbup.
  ENDLOOP.
* VBKD
  LOOP AT xmcvbkd WHERE supkz EQ con_supkz_unv.
    MOVE con_supkz_neu TO xmcvbkd-supkz.
    MODIFY xmcvbkd INDEX sy-tabix.
    MOVE con_supkz_alt TO xmcvbkd-supkz.
    APPEND xmcvbkd.
  ENDLOOP.
* Sortieren XMC-Tabellen.
  SORT xmcvbak BY supkz mandt vbeln.
  SORT xmcvbuk BY supkz mandt vbeln.
  SORT xmcvbap BY supkz mandt vbeln posnr.
  SORT xmcvbup BY supkz mandt vbeln posnr.
  SORT xmcvbkd BY supkz mandt vbeln posnr.
ENDFORM.                    "OLD_ENTRIES_PREPARE

*&---------------------------------------------------------------------*
*&      Form  anreichern_daten
*&---------------------------------------------------------------------*
*       Ergaenzen der Auftragkopf und -positionsdaten um               *
*       Retail- und Userdaten.                                         *
*----------------------------------------------------------------------*
*  -->  xmcvbak     Auftragkopftabelle
*  -->  xmcvbuk     Auftragkopfstatustabelle
*  -->  xmcvbap     Auftragpositionstabelle
*  -->  xmcvbup     Auftragpositionsstatustabelle
*  -->  xmcvbkd     Auftragposition Kaufmaennische Daten
*  -->  ad_control  Steuerfelder
*----------------------------------------------------------------------*
FORM anreichern_daten TABLES xmcvbak STRUCTURE mcvbakb
                             xmcvbuk STRUCTURE mcvbukb
                             xmcvbap STRUCTURE mcvbapb
                             xmcvbup STRUCTURE mcvbupb
                             xmcvbkd STRUCTURE mcvbkdb
                             mcinf   STRUCTURE mcsoinf
                      USING  value(ad_control) STRUCTURE mccontrol.
* nicht bei Simulation
  CHECK ad_control-modus NE con_modus_sim.

*  Definition Datenbereich Retail  Position
  DATA: BEGIN OF xmcvbapwws.
          INCLUDE STRUCTURE mcvbapwws.
  DATA: END OF xmcvbapwws.
* Definitions Datenbereich SAP BW Anreicherung
  DATA: bw_retail.
*  Definition Datenbereich Wareh.&Shipm. Position
  DATA: BEGIN OF xmcvbapwhs.
          INCLUDE STRUCTURE mcvbapwhs.
  DATA: END OF xmcvbapwhs.
*  Definition Datenbereich Userexit Position
  DATA: BEGIN OF xmcvbapusr.
          INCLUDE STRUCTURE mcvbapusr.
  DATA: END OF xmcvbapusr.
*  Definition Datenbereich Userexit Kopf
  DATA: BEGIN OF xmcvbakusr.
          INCLUDE STRUCTURE mcvbakusr.
  DATA: END OF xmcvbakusr.
*  Gewuenschte Datenerweiterungen
  DATA: BEGIN OF aktiv,
          retail,
          wareh_shipm,
          open_wkv,
          bw_appl(3),
          userexit,
        END OF aktiv.
*  Pruefen ob Anreicherungen gewuenscht sind
  PERFORM pruefen_anreichern TABLES   mcinf
                             CHANGING aktiv-retail
                                      aktiv-wareh_shipm
                                      aktiv-bw_appl
                                      aktiv-userexit.
  PERFORM absicherungsform_wkv(saplvkmp) CHANGING rc.
  IF rc IS INITIAL.
    aktiv-open_wkv = true.
  ENDIF.
*
  CHECK NOT aktiv IS INITIAL.
* Erzeugen alte Eintraege, wenn nichts veraendert wurde
  PERFORM old_entries_prepare TABLES xmcvbak xmcvbuk xmcvbap xmcvbup
                                     xmcvbkd.
*  Kopfdaten
  LOOP AT xmcvbak.
    READ TABLE xmcvbuk WITH KEY
        supkz = xmcvbak-supkz
        mandt = xmcvbak-mandt
        vbeln = xmcvbak-vbeln BINARY SEARCH.
*     Anreicherung Userexit-Daten VBAK
    IF NOT aktiv-userexit IS INITIAL.
      READ TABLE xmcvbkd WITH KEY
          supkz = xmcvbak-supkz
          mandt = xmcvbak-mandt
          vbeln = xmcvbak-vbeln
          posnr = '000000'      BINARY SEARCH.
      PERFORM userexit_kopf_ergaenzen USING xmcvbak xmcvbuk
                                            xmcvbkd ad_control
                                   CHANGING xmcvbakusr.
      MOVE-CORRESPONDING xmcvbakusr TO xmcvbak.
      MODIFY xmcvbak.
    ENDIF.
*   Position
    READ TABLE xmcvbap WITH KEY
       supkz = xmcvbak-supkz
       mandt = xmcvbak-mandt
       vbeln = xmcvbak-vbeln BINARY SEARCH.
    IF sy-subrc EQ 0.
      LOOP AT xmcvbap FROM sy-tabix.
        IF xmcvbap-supkz NE xmcvbak-supkz
        OR xmcvbap-mandt NE xmcvbak-mandt
        OR xmcvbap-vbeln NE xmcvbak-vbeln.
          EXIT.
        ENDIF.
*
        READ TABLE xmcvbup WITH KEY
           mandt = xmcvbap-mandt
           supkz = xmcvbap-supkz
           vbeln = xmcvbap-vbeln
           posnr = xmcvbap-posnr BINARY SEARCH.
*
        READ TABLE xmcvbkd WITH KEY
           supkz = xmcvbak-supkz
           mandt = xmcvbak-mandt
           vbeln = xmcvbak-vbeln
           posnr = xmcvbap-posnr BINARY SEARCH.
        IF sy-subrc NE 0.
          READ TABLE xmcvbkd WITH KEY
             supkz = xmcvbak-supkz
             mandt = xmcvbak-mandt
             vbeln = xmcvbak-vbeln
             posnr = '000000' BINARY SEARCH.
        ENDIF.
*       Anreicherung Retail-Daten Position
        IF NOT aktiv-retail IS INITIAL.
          PERFORM retail_pos_ergaenzen
                          USING xmcvbak xmcvbuk xmcvbap xmcvbup
                                xmcvbkd ad_control
                          CHANGING xmcvbapwws
                                   xmcvbapusr.
          MOVE-CORRESPONDING xmcvbapwws TO xmcvbap.
          MOVE-CORRESPONDING xmcvbapusr TO xmcvbap.
        ENDIF.
*       Anreicherung Warehouse&Shipment-Daten Position
        IF NOT aktiv-wareh_shipm IS INITIAL.
          PERFORM wareh_shipm_pos_ergaenzen
                        USING    xmcvbak xmcvbuk
                                 xmcvbap xmcvbup
                                 xmcvbkd ad_control
                        CHANGING xmcvbapwhs.
          MOVE-CORRESPONDING xmcvbapwhs TO xmcvbap.
        ENDIF.
*       Anreichern Daten SAP BW per BTE
        IF NOT aktiv-bw_appl IS INITIAL.
          CALL FUNCTION 'OUTBOUND_CALL_01000410_P'
            EXPORTING
              xmcvbak    = xmcvbak
              xmccontrol = ad_control
              bw_appl    = aktiv-bw_appl
            CHANGING
              xmcvbap    = xmcvbap.
        ENDIF.
*       Anreicherung Userexit-Daten Position
        IF NOT aktiv-userexit IS INITIAL.
          PERFORM userexit_pos_ergaenzen
                        USING xmcvbak xmcvbuk xmcvbap xmcvbup
                              xmcvbkd ad_control
                        CHANGING xmcvbapusr.
          MOVE-CORRESPONDING xmcvbapusr TO xmcvbap.
        ENDIF.
*       Anreicherung WKV-Daten Position
        IF NOT aktiv-open_wkv IS INITIAL AND
           NOT xmcvbap-abfor IS INITIAL.
          PERFORM wkv_pos_ergaenzen
                        USING    xmcvbak xmcvbuk
                                 xmcvbap xmcvbup
                                 xmcvbkd ad_control
                        CHANGING xmcvbapusr.
          MOVE-CORRESPONDING xmcvbapusr TO xmcvbap.
        ENDIF.
*
        MODIFY xmcvbap.
      ENDLOOP.
    ENDIF.
*   Warehouse&Shipment Belegende-Verarbeitung
    IF NOT aktiv-wareh_shipm IS INITIAL.
      PERFORM wareh_shipm_belegende USING xmcvbak-vbeln.
    ENDIF.
  ENDLOOP.
ENDFORM.                    "ANREICHERN_DATEN

*&---------------------------------------------------------------------*
*&      Form  Pruefen_Anreichern
*&---------------------------------------------------------------------*
*       Pruefen ob
*       - Anreicherung für Retail
*       - Anreicherung für Warehouse&Shipment notwendig
*       - Userexitmodule vorhanden
*----------------------------------------------------------------------*
*  <--  Retail             Anreicherung für Retail gewuenscht
*  <--  Aktiv-Wareh_Shipm  Anreicherung für Wareh.&Shipment notwendig
*  <--  Aktiv-Userexit     Userexits vorhanden
*----------------------------------------------------------------------*
FORM pruefen_anreichern TABLES   mcinf       STRUCTURE mcsoinf
                        CHANGING retail      TYPE c
                                 wareh_shipm TYPE c
                                 bw_appl     TYPE csequence
                                 userexit    TYPE c.
* Konstanten
  INCLUDE lv53ccon.
* Var.
  DATA: sdord LIKE tmcw-sdord.

*** BEGIN DSEG ***
  DATA: WA_TMCW LIKE TMCW.

  IF TMCW_READ_DB IS INITIAL.
*   ..Lese Mandanteneintrag ob WWS-Anreicherung gewuenscht
    SELECT SINGLE * FROM TMCW CLIENT SPECIFIED INTO WA_TMCW
                    WHERE MANDT EQ SY-MANDT.
    IF SY-SUBRC = 0.
      TMCW_READ_DB = TMCW_DB_RA.       "DB read -> activ
    ELSE.
      TMCW_READ_DB = TMCW_DB_RN.       "DB read -> not activ
    ENDIF.
  ENDIF.

  IF TMCW_READ_DB EQ TMCW_DB_RA.
*** END DSEG ***

*   Pruefen ob Retailanreicherung gewuenscht
    CALL FUNCTION 'WIS_CHECK_ADD_CONTENTS_ACTIV'
      IMPORTING
        e_retail_order   = sdord
      EXCEPTIONS
        retail_not_activ = 1
        OTHERS           = 2.
*   Retail-Hauptschalter an + Anreicherung Auftrag?
    IF SY-SUBRC = 0 AND NOT SDORD IS INITIAL.
*     ja, dann anreichern für Retail
      RETAIL = 'X'.
    ELSE.
      CLEAR RETAIL.
    ENDIF.

*** BEGIN DSEG ***
  ELSE.
    CLEAR retail.
  ENDIF.
*** END DSEG.

* Pruefen ob Anreicherung für Warehouse&Shipment notwendig
  CALL FUNCTION 'SD_WHS_CHECK_ENRICHMENT_ACTIV'
    EXPORTING
      i_call_from = call_from_customer_order
    IMPORTING
      e_activ     = wareh_shipm
    TABLES
      t_mcinf     = mcinf.

* Pruefen ob Anreicherung für SAP BW erwünscht
  CALL FUNCTION 'OUTBOUND_CALL_01000411_P'
    IMPORTING
      e_bw_appl      = bw_appl
    EXCEPTIONS
      no_appl_active = 1
      no_funct_found = 2
      OTHERS         = 3.
  IF sy-subrc NE 0.
    CLEAR bw_appl.
  ENDIF.

* Pruefen ob Userexits vorhanden
  CALL FUNCTION 'MODX_FUNCTION_ACTIVE_CHECK'
    EXPORTING
      cprogname = 'SAPLMCS1'
    IMPORTING
      active    = userexit
    EXCEPTIONS
      not_found = 4.
  IF sy-subrc EQ 4.
    CLEAR userexit.
  ENDIF.
ENDFORM.                    "PRUEFEN_ANREICHERN

*&---------------------------------------------------------------------*
*&      Form  DELIVERY_SCHEDULE_DETERMINE
*&---------------------------------------------------------------------*
*       Abrufzustand alt ermitteln für LAB und FAB
*----------------------------------------------------------------------*
FORM delivery_schedule_determine TABLES t_mtp_vblb      STRUCTURE vblbvb
                                 USING value(us_vbeln)     TYPE vbeln
                                       value(us_posnr)     TYPE clike
                                       value(us_abart_lab) TYPE clike
                                       value(us_abart_fab) TYPE clike
                                       value(us_abart_pab) TYPE clike.

* Zustand alt des LAB übergeben
  CALL FUNCTION 'SD_YVBLB_SELECT'
    EXPORTING
      i_document_number = us_vbeln
      i_item_number     = us_posnr
      i_type            = us_abart_lab
    IMPORTING
      e_yvblb           = t_mtp_vblb.
  IF NOT t_mtp_vblb-posnr IS INITIAL.
    APPEND t_mtp_vblb.
  ELSE.
* falls es keinen Zustand alt gibt, aktuellen Zustand übergeben
    CALL FUNCTION 'SD_VBLB_SELECT'
      EXPORTING
        i_document_number = us_vbeln
        i_item_number     = us_posnr
        i_type            = us_abart_lab
      IMPORTING
        e_vblb            = t_mtp_vblb.
    IF NOT t_mtp_vblb-posnr IS INITIAL.
      APPEND t_mtp_vblb.
    ENDIF.
  ENDIF.
* Zustand alt des FAB übergeben
  CALL FUNCTION 'SD_YVBLB_SELECT'
    EXPORTING
      i_document_number = us_vbeln
      i_item_number     = us_posnr
      i_type            = us_abart_fab
    IMPORTING
      e_yvblb           = t_mtp_vblb.
  IF NOT t_mtp_vblb-posnr IS INITIAL.
    APPEND t_mtp_vblb.
  ELSE.
* falls es keinen Zustand alt gibt, aktuellen Zustand übergeben
    CALL FUNCTION 'SD_VBLB_SELECT'
      EXPORTING
        i_document_number = us_vbeln
        i_item_number     = us_posnr
        i_type            = us_abart_fab
      IMPORTING
        e_vblb            = t_mtp_vblb.
    IF NOT t_mtp_vblb-posnr IS INITIAL.
      APPEND t_mtp_vblb.
    ENDIF.
  ENDIF.
* Zustand alt des PAB übergeben
  CALL FUNCTION 'SD_YVBLB_SELECT'
    EXPORTING
      i_document_number = us_vbeln
      i_item_number     = us_posnr
      i_type            = us_abart_pab
    IMPORTING
      e_yvblb           = t_mtp_vblb.
  IF NOT t_mtp_vblb-posnr IS INITIAL.
    APPEND t_mtp_vblb.
  ELSE.
* falls es keinen Zustand alt gibt, aktuellen Zustand übergeben
    CALL FUNCTION 'SD_VBLB_SELECT'
      EXPORTING
        i_document_number = us_vbeln
        i_item_number     = us_posnr
        i_type            = us_abart_pab
      IMPORTING
        e_vblb            = t_mtp_vblb.
    IF NOT t_mtp_vblb-posnr IS INITIAL.
      APPEND t_mtp_vblb.
    ENDIF.
  ENDIF.

ENDFORM.                    "DELIVERY_SCHEDULE_DETERMINE

*&---------------------------------------------------------------------*
*&      Form  retail_pos_ergaenzen                                     *
*&---------------------------------------------------------------------*
*       Ergaenzen der Fakturapositionsdaten um Retailinformationen     *
*----------------------------------------------------------------------*
*   ->  xmcvbak     Auftragkopf
*   ->  xmcvbuk     Auftragkopf Statis
*   ->  xmcvbap     Auftragposition
*   ->  xmcvbup     Auftragposition Statis
*  <-   xmcvbapwws  Retail Positionsdaten
*  <-   xmcvbapusr  Retail Positionsdaten Warengr.-/Betriebshierarchie
*---------------------------------------------------------------------*
FORM retail_pos_ergaenzen USING xmcvbak STRUCTURE mcvbakb
                                xmcvbuk STRUCTURE mcvbukb
                                xmcvbap STRUCTURE mcvbapb
                                xmcvbup STRUCTURE mcvbupb
                                xmcvbkd STRUCTURE mcvbkdb
                                xmccontrol STRUCTURE mccontrol
                      CHANGING  xmcvbapwws STRUCTURE mcvbapwws
                                xmcvbapusr STRUCTURE mcvbapusr.
*   Anreichern Position um Retail-Daten
  CALL FUNCTION 'WIS_ADD_CONTENTS_VBAP'
    EXPORTING
      xmcvbak    = xmcvbak
      xmcvbap    = xmcvbap
      xmcvbkd    = xmcvbkd
      xmccontrol = xmccontrol
    IMPORTING
      xmcvbapwws = xmcvbapwws
      xmcvbapusr = xmcvbapusr.
ENDFORM.                    "RETAIL_POS_ERGAENZEN

*---------------------------------------------------------------------*
*       Form  WAREH_SHIPM_POS_ERGAENZEN
*---------------------------------------------------------------------*
*       Ergaenzen der Auftragpositionsdaten um Informationen
*       der Anwendung Warehouse&Shipment
*---------------------------------------------------------------------*
*  -->  xmcvbak     Auftragkopf
*  -->  xmcvbuk     Auftragkopf Statis
*  -->  xmcvbap     Auftragposition
*  -->  xmcvbup     Auftragposition Statis
*  -->  xmcvbkd     Auftragposition Kaufmännische Daten
*  -->  xmccontrol  LIS-Fortschreibung: Steuerparameter
*  <--  xmcvbapwhs  Erweiterungen Wareh.&Shipm. Positionsdaten
*----------------------------------------------------------------------*
FORM wareh_shipm_pos_ergaenzen
                 USING    xmcvbak    STRUCTURE mcvbakb
                          xmcvbuk    STRUCTURE mcvbukb
                          xmcvbap    STRUCTURE mcvbapb
                          xmcvbup    STRUCTURE mcvbupb
                          xmcvbkd    STRUCTURE mcvbkdb
                          xmccontrol STRUCTURE mccontrol
                 CHANGING xmcvbapwhs STRUCTURE mcvbapwhs.
  CALL FUNCTION 'SD_WHS_ADD_CONTENTS_VBAP'
    EXPORTING
      xmcvbak    = xmcvbak
      xmcvbuk    = xmcvbuk
      xmcvbkd    = xmcvbkd
      xmcvbap    = xmcvbap
      xmcvbup    = xmcvbup
      xmccontrol = xmccontrol
    IMPORTING
      xmcvbapwhs = xmcvbapwhs.
ENDFORM.                               "WAREH_SHIPM_POS_ERGAENZEN

*---------------------------------------------------------------------*
*       Form  WAREH_SHIPM_BELEGENDE
*---------------------------------------------------------------------*
*       Belegende-Verarbeitung Warehouse&Shipment
*---------------------------------------------------------------------*
*  -->  wsb_vbeln  Belegnummer
*---------------------------------------------------------------------*
FORM wareh_shipm_belegende USING wsb_vbeln LIKE mcvbak-vbeln.
  CALL FUNCTION 'SD_WHS_END_OF_DOCUMENT_VIS'
    EXPORTING
      i_vbeln = wsb_vbeln.
ENDFORM.                               "wareh_shipm_belegende

*&---------------------------------------------------------------------*
*&      Form  Userexit_Kopf_ergaenzen
*&---------------------------------------------------------------------*
*       Ergaenzen der Auftragpositionsdaten um Userexitinformationen   *
*----------------------------------------------------------------------*
*  -->  xmcvbak     Auftragkopf
*  -->  xmcvbuk     Auftragkopf Status
*  -->  uke_control Steuerfelder
*  <--  xmcvbakusr  Userexiterweiterungen Kopfdaten
*----------------------------------------------------------------------*
FORM userexit_kopf_ergaenzen USING xmcvbak STRUCTURE mcvbakb
                                   xmcvbuk STRUCTURE mcvbukb
                                   xmcvbkd STRUCTURE mcvbkdb
                                value(uke_control) STRUCTURE mccontrol
                       CHANGING xmcvbakusr STRUCTURE mcvbakusr.

  CALL CUSTOMER-FUNCTION '001'
    EXPORTING  i_xmcvbak    = xmcvbak
               i_xmcvbuk    = xmcvbuk
               i_xmcvbkd    = xmcvbkd
               i_control    = uke_control
    IMPORTING  e_xmcvbakusr = xmcvbakusr.

ENDFORM.                    "USEREXIT_KOPF_ERGAENZEN


*&---------------------------------------------------------------------*
*&      Form  Userexit_Pos_ergaenzen
*&---------------------------------------------------------------------*
*       Ergaenzen der Auftragpositionsdaten um Userexitinformationen   *
*----------------------------------------------------------------------*
*  -->  xmcvbak     Auftragkopf
*  -->  xmcvbuk     Auftragkopf Statis
*  -->  xmcvbap     Auftragposition
*  -->  xmcvbup     Auftragposition Statis
*  -->  upe_control Steuerfelder
*  <--  xmcvbapusr  Userexiterweiterungen Positionsdaten
*----------------------------------------------------------------------*
FORM userexit_pos_ergaenzen USING xmcvbak STRUCTURE mcvbakb
                                  xmcvbuk STRUCTURE mcvbukb
                                  xmcvbap STRUCTURE mcvbapb
                                  xmcvbup STRUCTURE mcvbupb
                                  xmcvbkd STRUCTURE mcvbkdb
                                  value(upe_control) STRUCTURE mccontrol
                      CHANGING xmcvbapusr STRUCTURE mcvbapusr.

  CALL CUSTOMER-FUNCTION '002'
    EXPORTING  i_xmcvbak    = xmcvbak
               i_xmcvbuk    = xmcvbuk
               i_xmcvbap    = xmcvbap
               i_xmcvbup    = xmcvbup
               i_xmcvbkd    = xmcvbkd
               i_control    = upe_control
    IMPORTING  e_xmcvbapusr = xmcvbapusr.

ENDFORM.                    "USEREXIT_POS_ERGAENZEN

*---------------------------------------------------------------------*
*       FORM VBEPD_FUELLEN                                            *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  -->  US_XVBEP                                                      *
*  -->  CH_XMCVBEP                                                    *
*---------------------------------------------------------------------*
FORM vbepd_fuellen USING    us_xvbep   STRUCTURE vbepvb
                   CHANGING ch_xmcvbep STRUCTURE mcvbepb.
  MOVE-CORRESPONDING vbepd TO ch_xmcvbep.
  MOVE us_xvbep-swmeng     TO ch_xmcvbep-swmeng.
  MOVE us_xvbep-erdata     TO ch_xmcvbep-erdata.
  MOVE us_xvbep-aedata     TO ch_xmcvbep-aedata.
ENDFORM.                    "VBEPD_FUELLEN

*&---------------------------------------------------------------------*
*&      Form  WKV_POS_ERGAENZEN
*&---------------------------------------------------------------------*
*       Ergaenzen der Auftragpositionsdaten um WKV-Informationen       *
*----------------------------------------------------------------------*
*  -->  xmcvbak     Auftragkopf
*  -->  xmcvbuk     Auftragkopf Statis
*  -->  xmcvbap     Auftragposition
*  -->  xmcvbup     Auftragposition Statis
*  -->  upe_control Steuerfelder
*  <--  xmcvbapusr  Userexiterweiterungen Positionsdaten
*----------------------------------------------------------------------*
FORM wkv_pos_ergaenzen      USING xmcvbak STRUCTURE mcvbakb
                                  xmcvbuk STRUCTURE mcvbukb
                                  xmcvbap STRUCTURE mcvbapb
                                  xmcvbup STRUCTURE mcvbupb
                                  xmcvbkd STRUCTURE mcvbkdb
                                  value(upe_control) STRUCTURE mccontrol
                         CHANGING xmcvbapusr STRUCTURE mcvbapusr.
  CALL FUNCTION 'BF_FUNCTIONS_FIND'
    EXPORTING
      i_event       = con_event_vis_order
    TABLES
      t_fmrfc       = fmtab
    EXCEPTIONS
      nothing_found = 4.
  IF sy-subrc = 4.
    EXIT.
  ELSE.
    LOOP AT fmtab.
      CALL FUNCTION fmtab-funct
        EXPORTING
          status              = xmcvbap-supkz
          order_number        = xmcvbak-vbeln
          order_item_number   = xmcvbap-posnr
        CHANGING
          contract_order_data = xmcvbapusr
        EXCEPTIONS
          OTHERS              = 0.
    ENDLOOP.
  ENDIF.
ENDFORM.                    "WKV_POS_ERGAENZEN



*&---------------------------------------------------------------------*
*&      Form  OUTBOUND_CALL_00506002_E
*&---------------------------------------------------------------------*
* CMDS - Collaborative Management of Delivery Schedules
*
*       Outbound call after order statistics update
*       Usage:
*       1. Transfer of S073 data to APO (CMDS processing)
*----------------------------------------------------------------------*
*      -->P_MCINF
*      -->P_XMCKOMV
*      -->P_XMCVBAK
*      -->P_XMCVBAP
*      -->P_XMCVBAPF
*      -->P_XMCVBEP
*      -->P_XMCVBFA
*      -->P_XMCVBKD
*      -->P_XMCVBPA
*      -->P_XMCVBUK
*      -->P_XMCVBUP
*      -->P_XMCFPLT
*      -->P_CONTROL
*      -->P_ZEITP
*----------------------------------------------------------------------*
FORM outbound_call_00506002_e TABLES   p_mcinf    STRUCTURE mcsoinf
                                       p_xmckomv  STRUCTURE mckomvb
                                       p_xmcvbak  STRUCTURE mcvbakb
                                       p_xmcvbap  STRUCTURE mcvbapb
                                       p_xmcvbapf STRUCTURE mcvbafb
                                       p_xmcvbep  STRUCTURE mcvbepb
                                       p_xmcvbfa  STRUCTURE mcvbfab
                                       p_xmcvbkd  STRUCTURE mcvbkdb
                                       p_xmcvbpa  STRUCTURE mcvbpab
                                       p_xmcvbuk  STRUCTURE mcvbukb
                                       p_xmcvbup  STRUCTURE mcvbupb
                                       p_xmcfplt  STRUCTURE mcfpltb
                              USING    p_control  LIKE      mccontrol
                                       p_zeitp    LIKE      tmc2f-zeitp.

  CALL FUNCTION 'OUTBOUND_CALL_00506002_E'
    EXPORTING
      is_control  = p_control
      iv_zeitp    = p_zeitp
    TABLES
      it_mcinf    = p_mcinf
      it_xmckomv  = p_xmckomv
      it_xmcvbak  = p_xmcvbak
      it_xmcvbap  = p_xmcvbap
      it_xmcvbapf = p_xmcvbapf
      it_xmcvbep  = p_xmcvbep
      it_xmcvbfa  = p_xmcvbfa
      it_xmcvbkd  = p_xmcvbkd
      it_xmcvbpa  = p_xmcvbpa
      it_xmcvbuk  = p_xmcvbuk
      it_xmcvbup  = p_xmcvbup
      it_xmcfplt  = p_xmcfplt.

ENDFORM.                    " OUTBOUND_CALL_00506002_E